<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-12-17T17:52:12.450Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Astray Wu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PyQt5</title>
    <link href="http://yoursite.com/2021/12/17/PyQt5/"/>
    <id>http://yoursite.com/2021/12/17/PyQt5/</id>
    <published>2021-12-16T17:13:16.000Z</published>
    <updated>2021-12-17T17:52:12.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PyQt5-tutorial-ZetCode-笔记"><a href="#PyQt5-tutorial-ZetCode-笔记" class="headerlink" title="PyQt5 tutorial ZetCode 笔记"></a><a href="https://zetcode.com/gui/pyqt5/" target="_blank" rel="noopener">PyQt5 tutorial</a> ZetCode 笔记</h2><ol><li>Date and time<ol><li>Current date and time<br> a. Qt.ISOData<br> b. DefaultLocaleLongDate</li><li>UTC time</li><li>Number of days</li><li>Difference in days</li><li>Date arithmetic</li><li>Daylight saving time</li><li>Unix epoch</li><li>Julian day<br> 便于时间相减，直接计算天数</li></ol></li><li>Hello, world<ol><li>Simple example</li><li>Icon</li><li>Tooltip<br> a. Btn.sizeHint()</li><li>closeEvent<br> qbtn.clicked.connect(QApplication.instance().quit)</li><li>Message box</li><li>Center</li></ol></li><li>Menus and toolbar<ol><li>Statusbar</li><li>Menu</li><li>Sub menu</li><li>Check menu</li><li>Context menu</li><li>Toolbar</li><li>Main window</li></ol></li><li>Layout<ol><li>QHBoxlayout</li><li>QGridLayout</li></ol></li><li>Event and signal<ol><li>LED demo</li><li>Key event handler</li><li>Event object, mouse event</li><li>Push btn event sender</li><li>Emitting signal</li></ol></li><li>Dialog<ol><li>QDialog</li><li>QcolorDialog and QFrame</li><li>QFontDialog, btn.setSizePolicy</li><li>QFileDialog, Qaction.triggered, QMainWindow</li></ol></li><li>Qwidge1<ol><li>QCheckBox</li><li>Toggle button, color demo, Qcolor.setRed</li><li>Qslider</li><li>QProgressBar</li><li>QCalendarWidge</li></ol></li><li>QWidget2<ol><li>Qpixmap, Qlabel.setPixmap</li><li>QLineEdit</li><li>Qsplitter</li><li>QComBox 复选框</li></ol></li><li>Drag and Drop 稍微还是有些不理解<ol><li>Qdrag</li><li>QMineData</li><li>dragEnterEvent仅获取对应的类型</li><li>dropEvent设置drop时的动作</li></ol></li><li>QPainter<ol><li>Draw text</li><li>Draw point</li><li>Draw color</li><li>drawRect, setBrush</li><li>Qpen(line, curves, rectangle)</li><li>Qbrush</li><li>BezierCurve</li></ol></li></ol><h2 id="Python-and-PyQt-Building-a-GUI-Desktop-Calculator-笔记"><a href="#Python-and-PyQt-Building-a-GUI-Desktop-Calculator-笔记" class="headerlink" title="Python and PyQt: Building a GUI Desktop Calculator 笔记"></a><a href="https://realpython.com/python-pyqt-gui-calculator/" target="_blank" rel="noopener">Python and PyQt: Building a GUI Desktop Calculator</a> 笔记</h2><p>MVC典型流程，先画View，再设计控制逻辑Control，最后再设计计算模型Model，分步骤实现。</p><h2 id="Qt-Designer-and-Python-Build-Your-GUI-Applications-Faster-笔记"><a href="#Qt-Designer-and-Python-Build-Your-GUI-Applications-Faster-笔记" class="headerlink" title="Qt Designer and Python: Build Your GUI Applications Faster 笔记"></a><a href="https://realpython.com/qt-designer-python/#getting-started-with-qt-designer" target="_blank" rel="noopener">Qt Designer and Python: Build Your GUI Applications Faster</a> 笔记</h2><p>coding一个相当完整的mainwindow</p><h2 id="进一步熟悉"><a href="#进一步熟悉" class="headerlink" title="进一步熟悉"></a>进一步熟悉</h2><p>书籍《PyQt快速开发与实践》中介绍了一些基本内容，后续可以进一步掌握，包括设计师的使用，基础组件，布局管理，高级组件等，还是要结合实战进行更深入的学习和使用才行。</p><h2 id="1-参考链接"><a href="#1-参考链接" class="headerlink" title="1. 参考链接"></a>1. 参考链接</h2><ol><li><a href="https://www.pythonguis.com/pyqt5-tutorial/" target="_blank" rel="noopener">The complete PyQt5 tutorial — Create GUI applications with Pyth on</a></li><li><a href="https://www.riverbankcomputing.com/static/Docs/PyQt5/" target="_blank" rel="noopener">PyQt5 Reference Guide</a> 官方文档</li><li><a href="https://zetcode.com/gui/pyqt5/" target="_blank" rel="noopener">PyQt5 tutorial</a> ZetCode</li><li><a href="https://github.com/janbodnar/PyQt-Examples" target="_blank" rel="noopener">PyQt-Examples</a> Github contains more in-depth examples for different topics</li><li><a href="https://github.com/janbodnar/PyQt5-Tutorial-Examples" target="_blank" rel="noopener">PyQt5-Tutorial-Examples</a> Sources and images for ZetCode’s PyQt5 tutorial</li><li><a href="https://zhuanlan.zhihu.com/p/48373518" target="_blank" rel="noopener">PyQt5图形界面编程（目录）</a> 知乎</li><li>realpython的几个相关课程<ol><li><a href="https://realpython.com/python-pyqt-gui-calculator/" target="_blank" rel="noopener">Python and PyQt: Building a GUI Desktop Calculator</a> 入门制作一个计算器，手把手指导，很不错</li><li><a href="https://realpython.com/qt-designer-python/#getting-started-with-qt-designer" target="_blank" rel="noopener">Qt Designer and Python: Build Your GUI Applications Faster</a> QtDesigner的简单使用</li><li><a href="https://realpython.com/python-pyqt-layout/" target="_blank" rel="noopener">PyQt Layouts: Create Professional-Looking GUI Applications</a></li><li><a href="https://realpython.com/bulk-file-rename-tool-python/" target="_blank" rel="noopener">Build a Bulk File Rename Tool With Python and PyQt</a></li><li><a href="https://realpython.com/python-menus-toolbars/" target="_blank" rel="noopener">Python and PyQt: Creating Menus, Toolbars, and Status Bars</a></li><li><a href="https://realpython.com/python-pyqt-database/" target="_blank" rel="noopener">Handling SQL Databases With PyQt: The Basics</a></li><li><a href="https://realpython.com/python-pyqt-qthread/" target="_blank" rel="noopener">Use PyQt’s QThread to Prevent Freezing GUIs</a></li><li><a href="https://realpython.com/python-contact-book/" target="_blank" rel="noopener">Build a Contact Book With Python, PyQt, and SQLite</a></li><li>相关的repo <a href="https://github.com/realpython/materials" target="_blank" rel="noopener">materials</a></li></ol></li><li><a href="https://doc.qt.io/qt-5/qtdesigner-manual.html" target="_blank" rel="noopener">Qt Designer Manual</a></li><li><a href="https://www.cnblogs.com/linyfeng/p/11223707.html" target="_blank" rel="noopener">[ PyQt入门教程 ] Qt Designer工具的使用</a> 使用qtdesigner实现登录框和业务逻辑代码</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PyQt5-tutorial-ZetCode-笔记&quot;&gt;&lt;a href=&quot;#PyQt5-tutorial-ZetCode-笔记&quot; class=&quot;headerlink&quot; title=&quot;PyQt5 tutorial ZetCode 笔记&quot;&gt;&lt;/a&gt;&lt;a href=&quot;ht</summary>
      
    
    
    
    
    <category term="Python Qt PyQt5 GUI" scheme="http://yoursite.com/tags/Python-Qt-PyQt5-GUI/"/>
    
  </entry>
  
  <entry>
    <title>test20211213</title>
    <link href="http://yoursite.com/2021/12/13/test20211213/"/>
    <id>http://yoursite.com/2021/12/13/test20211213/</id>
    <published>2021-12-12T17:38:03.000Z</published>
    <updated>2021-12-12T17:38:51.445Z</updated>
    
    <content type="html"><![CDATA[<p>参考<a href="https://www.cnblogs.com/linlf03/p/6923519.html" target="_blank" rel="noopener">TortoiseSVN比较工具设置为BeyondCompare 4</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考&lt;a href=&quot;https://www.cnblogs.com/linlf03/p/6923519.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TortoiseSVN比较工具设置为BeyondCompare 4&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Qt之QTimer</title>
    <link href="http://yoursite.com/2019/05/12/Qt%E4%B9%8BQTimer/"/>
    <id>http://yoursite.com/2019/05/12/Qt%E4%B9%8BQTimer/</id>
    <published>2019-05-12T08:18:06.000Z</published>
    <updated>2021-12-12T17:27:14.382Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="http://www.qter.org/portal.php?mod=view&amp;aid=37" target="_blank" rel="noopener">第10篇 Qt5基础（十）Qt定时器和随机数</a></li><li><a href="https://blog.csdn.net/zz2862625432/article/details/79550285" target="_blank" rel="noopener">QT之 QTimer使用方法</a></li><li><a href="https://blog.csdn.net/liang19890820/article/details/52302879" target="_blank" rel="noopener">Qt 之 QProgressBar</a></li></ul><p>效果图如下，定时器设置为100ms触发，进度条也随之滚进。</p><p><img src="/2019/05/12/Qt之QTimer/demo_QTimer.gif" alt></p><p><strong>MainWindow.h</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtWidgets/QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_MainWindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QProgressBar&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span> :</span> <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MainWindow(QWidget *parent = Q_NULLPTR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Ui::MainWindowClass ui;</span><br><span class="line">    QTimer *timer_;</span><br><span class="line">    QProgressBar *progress_;</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UpdateProgress</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>MainWindow.cpp</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MainWindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLayout&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent) &#123;</span><br><span class="line">    ui.setupUi(<span class="keyword">this</span>);</span><br><span class="line">    timer_ = <span class="keyword">new</span> QTimer(<span class="keyword">this</span>);</span><br><span class="line">    timer_-&gt;setInterval(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    progress_ = <span class="keyword">new</span> QProgressBar(<span class="keyword">this</span>);</span><br><span class="line">    progress_-&gt;setRange(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">    progress_-&gt;setValue(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    QPushButton *okBtn = <span class="keyword">new</span> QPushButton(<span class="keyword">this</span>);</span><br><span class="line">    okBtn-&gt;setText(tr(<span class="string">"ok"</span>));</span><br><span class="line"></span><br><span class="line">    QPushButton *cancelBtn = <span class="keyword">new</span> QPushButton(<span class="keyword">this</span>);</span><br><span class="line">    cancelBtn-&gt;setText(tr(<span class="string">"cancel"</span>));</span><br><span class="line"></span><br><span class="line">    QHBoxLayout *btnLayout = <span class="keyword">new</span> QHBoxLayout();</span><br><span class="line">    btnLayout-&gt;addWidget(okBtn);</span><br><span class="line">    btnLayout-&gt;addWidget(cancelBtn);</span><br><span class="line">    QVBoxLayout *mainLayout = <span class="keyword">new</span> QVBoxLayout();</span><br><span class="line">    mainLayout-&gt;addWidget(progress_);</span><br><span class="line">    mainLayout-&gt;addLayout(btnLayout);</span><br><span class="line"></span><br><span class="line">    QWidget *widget = <span class="keyword">new</span> QWidget(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//setCentralWidget(widget);</span></span><br><span class="line">    <span class="comment">//centralWidget()-&gt;setLayout(mainLayout);</span></span><br><span class="line"></span><br><span class="line">    widget-&gt;setLayout(mainLayout);</span><br><span class="line">    setCentralWidget(widget);</span><br><span class="line"></span><br><span class="line">    connect(okBtn, &amp;QPushButton::clicked, timer_, <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> (QTimer::*)()&gt; (&amp;QTimer::start));</span><br><span class="line">    connect(cancelBtn, &amp;QPushButton::clicked, timer_, &amp;QTimer::stop);</span><br><span class="line">    connect(timer_, &amp;QTimer::timeout, <span class="keyword">this</span>, &amp;MainWindow::UpdateProgress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::UpdateProgress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> curVal = progress_-&gt;value();</span><br><span class="line">    ++curVal;</span><br><span class="line">    <span class="keyword">if</span> (curVal &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">        curVal = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    progress_-&gt;setValue(curVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main.cpp</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MainWindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtWidgets/QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    MainWindow w;</span><br><span class="line">    w.show();</span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.qter.org/portal.php?mod=view&amp;amp;aid=37&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;第10篇 Qt5基础（十）Qt定时器和随机数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Qt多线程</title>
    <link href="http://yoursite.com/2019/05/12/Qt%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/05/12/Qt%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2019-05-11T16:00:06.000Z</published>
    <updated>2021-12-12T17:27:14.385Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在弄Qt的多线程，简要记录一些心得。</p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul><li><a href="https://blog.csdn.net/czyt1988/article/details/64441443" target="_blank" rel="noopener">Qt使用多线程的一些心得——1.继承QThread的多线程使用方法 CSDN</a> 写得还是挺不错的，比较实用</li><li><a href="https://blog.csdn.net/czyt1988/article/details/71194457" target="_blank" rel="noopener">Qt使用多线程的一些心得——2.继承QObject的多线程使用方法 CSDN</a></li></ul><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>Qt有两种多线程方法，一种是继承QThread的run函数，另一种是把继承于QObject的类转移到新的Thread里。Qt4.8一般采用继承QThread的方法，但在4.8之后官方建议采用第二种方法，使用会更加灵活一些。<br>网络上较多的方法是采用第一种，包括很多书籍教程也是，这里把两种方法都进行下记录。</p><p>通常，应用程序都是在一个线程中执行的，但当调用一个好事操作，例如大批量Io或大量矩阵变换等CPU密集操作时，用于界面常常会冻结，可以使用多线程来解决这些问题。</p><p>优势</p><ol><li>提高应用程序的响应速度，尤其对于GUI来说，如果某个操作耗时很长，整个系统都在等待，将不能响应鼠标、键盘、菜单等操作。利用多线程可以将耗时操作放到一个新的线程中，避免该问题。</li><li>使多CPU更加有效</li><li>改善程序结构，将复杂的进行拆成多个线程，成为独立或半独立的运行部分，有利于代码的理解和维护。</li></ol><p>不足</p><ol><li>行为无法预期，多次执行结果可能不尽相同</li><li>多线程的执行顺序无法保证，与操作系统地调度策略和线程优先级有关</li><li>多线程的切换可能发生在任何时间和地点</li><li>对代码的敏感度较高，细微修改都可能造成意向不到的结果</li></ol><h3 id="继承QThread"><a href="#继承QThread" class="headerlink" title="继承QThread"></a>继承QThread</h3><p>使用Qthread时有一个重要的规则，<strong>QThread只有run函数是在新线程里的，其他所有函数都在QThread生成的线程里</strong>。之前某个写法一直阻塞UI就是因为我在前天函数进行了操作，但其他函数并不是在子线程中的。所以要注意以下两点：</p><ol><li>如果QThread是在ui所在线程里成成，那么QThread的其他非run函数都是和ui一样的，要确保耗时的操作都在run函数中完成。<br>在UI线程下调用QThread的非run函数和执行普通函数没有区别。但要注意，如果这2. 个函数对线程的某个变量进行变更，并且该变量在run函数中也会使用，就要注意同步的问题，因为虽然都是QThread的类里，但run和非run函数实际上两个不同线程进行的，之间可能有竞争。</li></ol><p>任何继承于QThread的线程都是通过继承QThread的run函数来实现多线程的，因此，必须重写QThread的run函数，把复杂逻辑写在QThread的run函数中。</p><p>参考博客提供的代码，如下，稍微替换了下命名风格。该类继承自QThread，包含了Qt类的常见内容，包括普通方法，信号和槽，还有run函数。其中<code>SetSth, GetSth, DoSth</code>函数都进行了500ms的延迟，用于验证在<code>QThread::run()</code>之外调用QThread的成员函数并会在新的线程中运行。</p><p><strong>ThreadFromQThread.h</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QThread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadFromQThread</span> :</span> <span class="keyword">public</span> QThread &#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Msg</span><span class="params">(<span class="keyword">const</span> QString&amp; info)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Progress</span><span class="params">(<span class="keyword">int</span> present)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ThreadFromQThread(QObject* par);</span><br><span class="line">    ~ThreadFromQThread();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetSth</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetSth</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set_runCnt</span><span class="params">(<span class="keyword">int</span> count)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSth</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> runCnt_;</span><br><span class="line">    QMutex mutex_;</span><br><span class="line">    <span class="keyword">bool</span> canRun_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StopImmediately</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>ThreadFromQThread.cpp</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ThreadFromQThread.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMutex&gt;</span></span></span><br><span class="line">ThreadFromQThread::ThreadFromQThread(QObject* par) : QThread(par)</span><br><span class="line">, runCnt_(<span class="number">20</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadFromQThread::~ThreadFromQThread() &#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"ThreadFromQThread::~ThreadFromQThread()"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFromQThread::SetSth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    msleep(<span class="number">500</span>);</span><br><span class="line">    QString str = QString(<span class="string">"%1-&gt;%2,thread id:%3"</span>).arg(__FUNCTION__).arg(__FILE__).arg((<span class="keyword">int</span>)QThread::currentThreadId());</span><br><span class="line">    <span class="function">emit <span class="title">Msg</span><span class="params">(str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFromQThread::GetSth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    msleep(<span class="number">500</span>);</span><br><span class="line">    <span class="function">emit <span class="title">Msg</span><span class="params">(QString(<span class="string">"%1-&gt;%2,thread id:%3"</span>).arg(__FUNCTION__).arg(__FILE__).arg((<span class="keyword">int</span>)QThread::currentThreadId()))</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFromQThread::Set_runCnt</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    runCnt_ = count;</span><br><span class="line">    <span class="function">emit <span class="title">Msg</span><span class="params">(QString(<span class="string">"%1-&gt;%2,thread id:%3"</span>).arg(__FUNCTION__).arg(__FILE__).arg((<span class="keyword">int</span>)QThread::currentThreadId()))</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFromQThread::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    QString str = QString(<span class="string">"%1-&gt;%2,thread id:%3"</span>).arg(__FILE__).arg(__FUNCTION__).arg((<span class="keyword">int</span>)QThread::currentThreadId());</span><br><span class="line">    <span class="function">emit <span class="title">Msg</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>); <span class="comment">// 共20秒完成一次进度条，不过doSth还会暂停一点时间</span></span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="function">emit <span class="title">Progress</span><span class="params">(((<span class="keyword">float</span>)cnt / runCnt_) * <span class="number">100</span>)</span></span>;</span><br><span class="line">        <span class="function">emit <span class="title">Msg</span><span class="params">(QString(<span class="string">"ThreadFromQThread::run times:%1"</span>).arg(cnt))</span></span>;</span><br><span class="line">        DoSth();</span><br><span class="line">        <span class="keyword">if</span> (runCnt_ == cnt) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (!canRun_)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFromQThread::DoSth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    msleep(<span class="number">500</span>);</span><br><span class="line">    <span class="function">emit <span class="title">Msg</span><span class="params">(QString(<span class="string">"%1-&gt;%2,thread id:%3"</span>).arg(__FUNCTION__).arg(__FILE__).arg((<span class="keyword">int</span>)QThread::currentThreadId()))</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFromQThread::StopImmediately</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">    canRun_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>博主提供了如下的UI界面，用于验证：</p><ol><li>UI线程中调用SetSth和GetSth，是否会阻塞UI线程</li><li>调用quit函数和exit是否会停止子线程</li><li>调用terminte是否会停止子线程</li></ol><p>基本效果如下<br><img src="/2019/05/12/Qt多线程/QtThreadDemo.gif" alt></p><p>UI界面上提供一个进度条，由主程序的定时器控制，每100ms触发一次，用于证明UI线程是否阻塞。<br>第二个进度条由子线程控制。<br>run按钮会运行子线程。<br>点击getSth, setSth, doSth等按钮时候，都是调用子线程类中的非run函数，可以看到对应的thread ID其实并不是子线程的ID。<br>并且点击quit，thread没有任何响应，QThread在不调用exec()的情况下的exit和quit函数不会起作用。<br>点击terminate按钮，线程立即终止。</p><p>总结一下：</p><ol><li>正确终止子线程<br>在子线程类中添加bool变量，主线程修改该变量然后在线程的run函数中判断是否退出。注意要用QMutexLocker枷锁判断，避免线程冲突。</li><li>正确启动线程<ol><li>全局线程<br>  方法一：在窗口中创建，在窗口析构时要先调用线程的wait函数，等待子线程完全结束<br>  方法二：创建时连接<code>connect(thread, &amp;QThread::finished, &amp;QObject::deleteLater;</code>，父对象为<code>NULL</code>，在线程结束时自行销毁（消息循环中确认没有该对象后析构）</li><li>局部线程<br>  采用以上方法二即可</li></ol></li><li>重复创建子线程时，可能要注意重复生成还有析构，以及时切换到新线程中完成任务，参考代码。</li></ol><h3 id="继承QObject"><a href="#继承QObject" class="headerlink" title="继承QObject"></a>继承QObject</h3><p>Qt官方比较推荐继承QObject的方法来实现，更加灵活。<br>QObject是Qt框架的基本类，但凡涉及到信号槽有关的类都是继承于QObject。QObject是一个功能异常强大的类，它提供了Qt关键技术信号和槽的支持以及事件系统的支持，同时它提供了线程操作的接口，也就是QObject是可以选择不同的线程里执行的。<br>QObject的线程转移函数是：void moveToThread(QThread * targetThread) ，通过此函数可以把一个顶层Object（就是没有父级）转移到一个新的线程里。<br>QThread非常容易被新手误用，主要是QThread自身并不生存在它run函数所在的线程，而是生存在旧的线程中，此问题在上一篇重点描述了。由于QThread的这个特性，导致在调用QThread的非run函数容易在旧线程中执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这两天在弄Qt的多线程，简要记录一些心得。&lt;/p&gt;
&lt;h2 id=&quot;ref&quot;&gt;&lt;a href=&quot;#ref&quot; class=&quot;headerlink&quot; title=&quot;ref&quot;&gt;&lt;/a&gt;ref&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yoursite.com/2019/05/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/05/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2019-05-09T15:25:45.000Z</published>
    <updated>2021-12-12T17:27:14.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>这个工具还是得找个机会熟悉起来，用的机会太少了，但感觉很有必要。</p><ul><li><a href="https://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">正则表达式 - 教程 菜鸟教程</a></li><li><a href="https://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">正则表达式30分钟入门教程</a></li><li><a href="https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm" target="_blank" rel="noopener">正则表达式（RegEx）——快速参考</a></li><li><a href="https://www.runoob.com/regexp/regexp-metachar.html" target="_blank" rel="noopener">正则表达式 - 元字符</a></li><li><a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference" target="_blank" rel="noopener">Regular Expression Language - Quick Reference</a></li><li><a href="https://www.zhihu.com/topic/19577832/top-answers" target="_blank" rel="noopener">正则表达式 知乎</a></li><li><a href="http://www.imooc.com/article/details/id/20793" target="_blank" rel="noopener">最实用的正则表达式整理</a></li><li><a href="https://zhuanlan.zhihu.com/p/29707385" target="_blank" rel="noopener">《JavaScript 正则表达式迷你书》问世了！</a></li><li><a href="https://www.zhihu.com/question/20197998/answer/17118246" target="_blank" rel="noopener">学习正则表达式有哪些入门和进阶的书籍？ 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/27653434" target="_blank" rel="noopener">正则表达式系列总结</a></li><li><a href="https://www.zhihu.com/question/48219401" target="_blank" rel="noopener">你是如何学会正则表达式的？</a></li></ul><h2 id="正则表达式示例"><a href="#正则表达式示例" class="headerlink" title="正则表达式示例"></a>正则表达式示例</h2><ul><li><a href="https://www.runoob.com/regexp/regexp-example.html" target="_blank" rel="noopener">正则表达式 - 示例 菜鸟教程</a></li><li><a href="https://c.runoob.com/front-end/854" target="_blank" rel="noopener">正则表达式在线测试 菜鸟教程</a></li><li><a href="https://www.jb51.net/tools/regexsc.htm" target="_blank" rel="noopener">常用正则表达式 jb51</a></li><li><a href="http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html" target="_blank" rel="noopener">最全的常用正则表达式大全——包括校验数字、字符、一些特殊的需求等等</a></li><li><a href="https://www.jianshu.com/p/e7bb97218946" target="_blank" rel="noopener">知道这20个正则表达式，能让你少写1,000行代码</a></li></ul><h2 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h2><ul><li><a href="https://regex101.com/" target="_blank" rel="noopener">regular epressions 101</a> 在线测试工具</li><li><a href="https://regexper.com/" target="_blank" rel="noopener">Regexper</a> 正则表达式可视化工具</li><li><a href="https://deerchao.net/tools/regester/index.htm" target="_blank" rel="noopener">Regester</a> 正则表达式测试工具</li></ul><h2 id="相关介绍"><a href="#相关介绍" class="headerlink" title="相关介绍"></a>相关介绍</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。</p><p>正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。</p><h3 id="为什么使用"><a href="#为什么使用" class="headerlink" title="为什么使用"></a>为什么使用</h3><p>典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。</p><p>通过使用正则表达式，可以：</p><ul><li>测试字符串内的模式。<br>  例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。</li><li>替换文本。<br>  可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。</li><li>基于模式匹配从字符串中提取子字符串。<br>  可以查找文档内或输入域内特定的文本。</li></ul><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>正则表达式是由<strong>普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）</strong>组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p><ul><li>普通字符<br>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</li><li>特殊字符<br>  所谓特殊字符，就是一些有特殊含义的字符，许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符\ 放在它们前面。</li><li><p>限定符<br>  用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有<code>*</code>或<code>+</code>或<code>?</code>或<code>{n}</code>或<code>{n,}</code>或<code>{n,m}</code>共6种。</p></li><li><p>定位符<br>  使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。</p><p>  定位符用来描述字符串或单词的边界，<code>^</code>和<code>$</code>分别指字符串的开始与结束，<code>\b</code>描述单词的前或后边界，<code>\B</code>表示非单词边界。</p></li><li><p>选择<br>用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。</p></li><li><p>反向引用<br>  对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从1开始，最多可存储99个捕获的子表达式。每个缓冲区都可以使用<code>\n</code>访问，其中<code>n</code>为一个标识特定缓冲区的一位或两位十进制数。</p></li></ul><h2 id="常用的元字符"><a href="#常用的元字符" class="headerlink" title="常用的元字符"></a>常用的元字符</h2><div class="table-container"><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>x&#124;y</td><td>匹配 x 或 y。例如，’z&#124;food’ 能匹配 “z” 或 “food”。’(z&#124;f)ood’ 则匹配 “zood” 或 “food”。</td></tr><tr><td>\b</td><td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td>\cx</td><td>匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td>\d</td><td>匹配一个数字字符。等价于 [0-9]。</td></tr><tr><td>\D</td><td>匹配一个非数字字符。等价于 <code>[^0-9]</code>。</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td></tr><tr><td>\S</td><td>匹配任何非空白字符。等价于 <code>[^ \f\n\r\t\v]</code>。</td></tr><tr><td>.</td><td>匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”(.&#124;\n)”的模式。</td></tr><tr><td>\w</td><td>匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。</td></tr><tr><td>\un</td><td>匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</td></tr><tr><td>(?=E)</td><td>表示表示表达式后紧随E才匹配, 例如要只在using后面是naemspace时才匹配using，用using(?=\s+namespace)</td></tr><tr><td>(?!E)</td><td>表示表示表达式后不跟随E才匹配</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ref&quot;&gt;&lt;a href=&quot;#ref&quot; class=&quot;headerlink&quot; title=&quot;ref&quot;&gt;&lt;/a&gt;ref&lt;/h2&gt;&lt;p&gt;这个工具还是得找个机会熟悉起来，用的机会太少了，但感觉很有必要。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>编程规范</title>
    <link href="http://yoursite.com/2019/05/07/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2019/05/07/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</id>
    <published>2019-05-06T18:03:10.000Z</published>
    <updated>2021-12-12T17:27:14.410Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://zh-google-styleguide.readthedocs.io/en/latest/" target="_blank" rel="noopener">Google 开源项目风格指南 (中文版)</a> 包含5个中文版的风格指南</li><li><a href="https://google.github.io/styleguide/cppguide.html" target="_blank" rel="noopener">Google C++ Style Guide</a></li><li><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/" target="_blank" rel="noopener">C++ 风格指南 - 内容目录</a></li><li><a href="https://blog.csdn.net/voidccc/article/details/37599203" target="_blank" rel="noopener">一张图总结Google C++编程规范(Google C++ Style Guide)</a></li></ul><p>华为的编程规范参考了很多的Google编程规范。</p><p>有一张图很好的总结了Google的编程规范<br><img src="/2019/05/07/编程规范/20140713220242000.jpg" alt></p><h2 id="Google编程规范笔记"><a href="#Google编程规范笔记" class="headerlink" title="Google编程规范笔记"></a>Google编程规范笔记</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><ol><li>避免使用前置声明，用头文件<br>优点：减少include，节省编译时间，减少重新编译头文件的可能<br>缺点：隐藏了依赖关系<br>前置声明是不完整类型</li><li>10行代码下才适合内联，不适用于循环和析构函数</li><li>include顺序<br>对应的头文件；C系统文件；C++系统文件；其他库的头文件；本项目的头文件<br>对应头文件放在最前面，可以在build的时候及时发现错误</li></ol><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ol><li>命名空间内不缩进</li><li>鼓励在cc文件中使用匿名命名空间和static声明，但不能在h文件中使用；（匿名空间其实就是文件作用域，类似于C中的static声明的作用域）</li><li>cc文件中的变量不会被外部文件引用时，使用匿名空间或者static，因为具有内部链接性，不会在其他文件中访问到；（尽可能限制作用域范围，避免污染）</li><li>静态成员函数或非成员函数最好放在命名空间中，静态成员应该是和类相关的，如果不相关最好放在命名空间中，尽量单独形成编译单元</li><li>禁止定义静态储存周期非POD变量，构造、析构和初始化可能是不确定的</li></ol><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ol><li>类定义中单参数的构造函数应该用<code>explicit</code>标记</li><li>优先组合，而非继承；虽然继承可以复用代码，但耦合性太高，散布在父子类之间的代码理解起来更不易；不能重写非虚函数；基类可能有自己的数据成员，对理解有挑战，实际很难拿捏准；</li><li>不要重载，除非确有需要，因为容易混淆，如重载</li><li>不在构造函数中做过多逻辑相关的初始化</li></ol><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol><li>入参在前，出参在后</li><li>输入参数是值参或const引用（不要使用非const引用，容易误解），输出参数为指针</li></ol><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>尽少使用默认参数，改用重载</li><li>不使用C++异常，得不偿失，虽然允许高层决定底层中不可能的失败，减少使用错误代码，但实际上常安全很困难，异常可能会扰乱程序的正常流程</li><li>禁用RTTI。RTTI虽然允许C++在运行时识别对象的类型，通过<code>dynamic_cast</code>和<code>typeid</code></li><li>用static_cast替代C风格的值转换</li><li>只在记录日志时使用流：否则容易混乱IO类型</li><li>内建整型仅用int，否则使用<code>&lt;stdint.h&gt;</code>中长度精确的整型</li><li>尽可能用<code>sizeof(varname)</code>代替<code>sizeof(type)</code>，因为变量类型改变时会自动更新</li><li>C++ 11中用nullptr，03用NULL</li><li>注意64位可移植型，例如对齐和指针大小等</li><li><p>预处理宏</p><ol><li>不在.h中使用宏</li><li>在马上使用时才定义</li></ol></li><li><p>不使用复杂的模板编程</p><ol><li>对不熟练C++的人难理解</li><li>编译出错的信息友好</li><li>重构工具难发挥</li><li>维护成本大于简洁的接口</li><li>对外接口不使用模板，仅在内部实现使用</li></ol></li></ol><h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><ol><li>文件名通通小写，下划线可用可不用</li><li>类型命名（类，结构体，类型定义，模板参数，枚举）使用大小写风格，首字母大写——这样可区分类与对象</li><li>变量、函数参数、成员数据均小写，下划线连接，类变量成员下划线结尾，结构体的不用</li><li>声明为const或constexpr的变量，k开头，大小写混合，静态变量同</li><li><p>函数也是大小写混合，大写开头，并且缩写字母也是首字母大写</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AddTableEntry()</span><br><span class="line">DeleteUrl()</span><br><span class="line">OpenFileOrDie()</span><br></pre></td></tr></table></figure></li><li><p>命名空间全小写</p></li><li><p>枚举类型采用常量风格，旧的不用改</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> UrlTableErrors &#123;</span><br><span class="line">kOK = <span class="number">0</span>,</span><br><span class="line">kErrorOutOfMemory,</span><br><span class="line">kErrorMalformedInput,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> AlternateUrlTableErrors &#123;</span><br><span class="line">    OK = <span class="number">0</span>,</span><br><span class="line">    OUT_OF_MEMORY = <span class="number">1</span>,</span><br><span class="line">    MALFORMED_INPUT = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ol><li>宏命名：全大写，下划线连接</li><li>行尾空格两格注释</li><li><p>TODO</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO(kl@gmail.com): Use a "*" here for concatenation operator.</span></span><br><span class="line"><span class="comment">// TODO(Zeke) change this to use relations.</span></span><br><span class="line"><span class="comment">// TODO(bug 12345): remove the "Last visitors" feature</span></span><br></pre></td></tr></table></figure></li><li><p>注释是为了看懂，不是炫耀语言水平，中英皆可</p></li><li>未被使用的参数注释掉<code>void Circle::Rotate(double /*radians*/) {}</code></li><li>if可单行，一行可不用花括号，分支中使用了花括号，其他都得加</li><li>空循环体用花括号</li><li>预处理不缩进，即使在缩进块内</li><li>public等缩进1格</li><li>命名空间不缩进</li><li><code>:</code>前后有空格</li></ol><h3 id="规则特例"><a href="#规则特例" class="headerlink" title="规则特例"></a>规则特例</h3><ol><li>现有不合规的代码网开一面</li></ol><h2 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h2><ul><li>Qt5开发及实例(完整版) P111</li></ul><ol><li>与Google的编码规范基本一致<ol><li>成员函数、成员变量命名风格，不过成员变量按照驼峰命名，小写开头，增加下划线</li><li>存取函数按照<code>Get_var</code>等进行</li></ol></li><li>控件统一在后面加后缀</li><li>V和H不需要细分，控件的细分不需要，只需要表达出是哪个控件就好，剩下的知识控件布局的问题，一般复杂度还可以。</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputDlg</span>:</span> <span class="keyword">public</span> QDialog</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    InputDlg(QWidget *parent = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ChangeName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ChangeSex</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ChangeAge</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QLabel *nameLabel1;</span><br><span class="line">    QLabel *sexLabel1;</span><br><span class="line">    QLabel *ageLabel1;</span><br><span class="line">    QLabel *nameLabel2;</span><br><span class="line">    QLabel *sexLabel2;</span><br><span class="line">    QLabel *ageLabel2;</span><br><span class="line">    QPushButton *nameBtn;</span><br><span class="line">    QPushButton *sexBtn;</span><br><span class="line">    QPushButton *scoreBtn;</span><br><span class="line">    QGridLayout *mainLayout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InputDlg::InputDlg(QWidget *parent = <span class="number">0</span>): QWidget(parent)</span><br><span class="line">&#123;</span><br><span class="line">    QLabel *queryLabel = <span class="keyword">new</span> QLabel(tr(<span class="string">"Query"</span>));</span><br><span class="line">    QLineEdit *queryEdit = <span class="keyword">new</span> QLineEdit();</span><br><span class="line">    QTableView *resView = <span class="keyword">new</span> QTableView();</span><br><span class="line"></span><br><span class="line">    QHBoxLayout *queryLayout = <span class="keyword">new</span> QHBoxLayout();</span><br><span class="line">    QVBoxLayout *mainLayout = <span class="keyword">new</span> QVBoxLayout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zh-google-styleguide.readthedocs.io/en/latest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google 开源项目风格指南 (中文版)&lt;/a&gt; 包含5个中文版的风</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>曲线调整</title>
    <link href="http://yoursite.com/2019/05/07/%E6%9B%B2%E7%BA%BF%E8%B0%83%E6%95%B4/"/>
    <id>http://yoursite.com/2019/05/07/%E6%9B%B2%E7%BA%BF%E8%B0%83%E6%95%B4/</id>
    <published>2019-05-06T18:00:31.000Z</published>
    <updated>2021-12-12T17:27:14.409Z</updated>
    
    <content type="html"><![CDATA[<p>有一段代码是利用高斯函数来做曲线拟合的，比较简单和方便，调试起来可能也会简单些。首先利用高斯函数生成0~256之间的sigma为75的曲线，第一个点按照1024归一化。大致如下<br><img src="/2019/05/07/曲线调整/2019-05-07-23-33-30.png" alt></p><p>然后利用标准正太分布公式来计算给定sigma和mean的高斯曲线。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STD_GS_LUT_Bit = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STD_GS_Sigma = <span class="number">75</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STD_GS_Mean = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STD_GS_PRCS = <span class="number">10</span>; <span class="comment">// prcs of output</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STD_GS_LUT_Sz = (<span class="number">1</span> &lt;&lt; STD_GS_LUT_Bit) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> STD_GS_LUT[STD_GS_LUT_Sz];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LUTInter</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> valBit, <span class="keyword">int</span> *LUT, <span class="keyword">int</span> LUTBit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> LUTSz = (<span class="number">1</span> &lt;&lt; LUTBit) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> shift = valBit - LUTBit;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> index = val &gt;&gt; shift;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= LUTSz - <span class="number">1</span>) &#123; <span class="comment">// index + 1&gt;= LUTSz -&gt; index + 1 &lt;= LUTSz - 1 -&gt; index + 1 &lt; LUTSz</span></span><br><span class="line">        <span class="keyword">return</span> LUT[LUTSz - <span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = LUT[index] + ((LUT[index + <span class="number">1</span>] - LUT[index]) * (val - (index &lt;&lt; shift)) &gt;&gt; shift);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LUTInterFromSTD_GS</span><span class="params">(<span class="keyword">int</span> *LUT, <span class="keyword">int</span> LUTSz = <span class="number">33</span>, <span class="keyword">int</span> mean = <span class="number">0</span>, <span class="keyword">int</span> sigma = <span class="number">80</span>, <span class="keyword">int</span> weight = <span class="number">50</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> STD_LUT_Bit = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> PRCS = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> shift = PRCS;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> scl = (STD_GS_Sigma &lt;&lt; shift) / sigma;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LUTSz; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">abs</span>((i &lt;&lt; <span class="number">8</span>) / LUTSz - mean) * scl &gt;&gt; <span class="number">8</span>;</span><br><span class="line">        LUT[i] = (weight * LUTInter(val, shift, STD_GS_LUT, STD_GS_LUT_Bit) + (<span class="number">1</span> &lt;&lt; (shift - <span class="number">1</span>))) &gt;&gt; shift;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CalcSTD_GS</span><span class="params">(<span class="keyword">int</span> *LUT, <span class="keyword">int</span> sz, <span class="keyword">int</span> prcs, <span class="keyword">int</span> sigma, <span class="keyword">int</span> mean)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// prcs 10</span></span><br><span class="line">    <span class="comment">// sigma U6.8</span></span><br><span class="line">    <span class="comment">// mean U6.8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> var = sigma / <span class="number">255.0</span> * sigma / <span class="number">255.0</span>;</span><br><span class="line">    <span class="keyword">double</span> u = mean / <span class="number">255</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) &#123;</span><br><span class="line">        <span class="keyword">double</span> val = i * <span class="number">1.0</span> / sz;</span><br><span class="line">        LUT[i] = round((<span class="number">1</span> &lt;&lt; prcs) * <span class="built_in">exp</span>(-(val - u) * (val - u) / (<span class="number">2</span> * var)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printmat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *p, <span class="keyword">int</span> len, <span class="keyword">const</span> <span class="keyword">char</span> *filename = <span class="string">"otuput.txt"</span>)</span> </span>&#123;</span><br><span class="line">    freopen(filename, <span class="string">"w"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%4d "</span>, p[i]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CalcSTD_GS(STD_GS_LUT, STD_GS_LUT_Sz, STD_GS_PRCS, STD_GS_Sigma, STD_GS_Mean);</span><br><span class="line">    printmat(STD_GS_LUT, STD_GS_LUT_Sz, <span class="string">"LUT_STD_GS.txt"</span>);</span><br><span class="line">    <span class="keyword">int</span> lut[<span class="number">33</span>];</span><br><span class="line">    LUTInterFromSTD_GS(lut, <span class="number">33</span>, <span class="number">0</span>, <span class="number">80</span>, <span class="number">128</span>);</span><br><span class="line">    printmat(lut, <span class="number">33</span>, <span class="string">"lut.txt"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ut();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clr;</span><br><span class="line"></span><br><span class="line">x = <span class="number">0</span>:<span class="number">256</span>;</span><br><span class="line">y = normpdf(x, <span class="number">0</span>, <span class="number">75</span>);</span><br><span class="line">y = (y / y(<span class="number">1</span>) * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">LUT = [<span class="number">1024</span> <span class="number">1024</span> <span class="number">1024</span> <span class="number">1023</span> <span class="number">1023</span> <span class="number">1022</span> <span class="number">1021</span> <span class="number">1020</span> <span class="number">1018</span> <span class="number">1017</span> <span class="number">1015</span> <span class="number">1013</span> <span class="number">1011</span> <span class="number">1009</span> <span class="number">1007</span> <span class="number">1004</span> <span class="number">1001</span>  <span class="number">998</span>  <span class="number">995</span>  <span class="number">992</span>  <span class="number">989</span>  <span class="number">985</span>  <span class="number">982</span>  <span class="number">978</span>  <span class="number">974</span>  <span class="number">969</span>  <span class="number">965</span>  <span class="number">961</span>  <span class="number">956</span>  <span class="number">951</span>  <span class="number">946</span>  <span class="number">941</span>  <span class="number">936</span>  <span class="number">931</span>  <span class="number">925</span>  <span class="number">920</span>  <span class="number">914</span>  <span class="number">908</span>  <span class="number">902</span>  <span class="number">896</span>  <span class="number">890</span>  <span class="number">884</span>  <span class="number">878</span>  <span class="number">871</span>  <span class="number">864</span>  <span class="number">858</span>  <span class="number">851</span>  <span class="number">844</span>  <span class="number">837</span>  <span class="number">830</span>  <span class="number">823</span>  <span class="number">816</span>  <span class="number">808</span>  <span class="number">801</span>  <span class="number">793</span>  <span class="number">786</span>  <span class="number">778</span>  <span class="number">771</span>  <span class="number">763</span>  <span class="number">755</span>  <span class="number">747</span>  <span class="number">739</span>  <span class="number">731</span>  <span class="number">724</span>  <span class="number">716</span>  <span class="number">708</span>  <span class="number">699</span>  <span class="number">691</span>  <span class="number">683</span>  <span class="number">675</span>  <span class="number">667</span>  <span class="number">659</span>  <span class="number">651</span>  <span class="number">642</span>  <span class="number">634</span>  <span class="number">626</span>  <span class="number">618</span>  <span class="number">609</span>  <span class="number">601</span>  <span class="number">593</span>  <span class="number">585</span>  <span class="number">577</span>  <span class="number">569</span>  <span class="number">560</span>  <span class="number">552</span>  <span class="number">544</span>  <span class="number">536</span>  <span class="number">528</span>  <span class="number">520</span>  <span class="number">512</span>  <span class="number">504</span>  <span class="number">496</span>  <span class="number">488</span>  <span class="number">480</span>  <span class="number">473</span>  <span class="number">465</span>  <span class="number">457</span>  <span class="number">449</span>  <span class="number">442</span>  <span class="number">434</span>  <span class="number">427</span>  <span class="number">419</span>  <span class="number">412</span>  <span class="number">405</span>  <span class="number">397</span>  <span class="number">390</span>  <span class="number">383</span>  <span class="number">376</span>  <span class="number">369</span>  <span class="number">362</span>  <span class="number">355</span>  <span class="number">348</span>  <span class="number">342</span>  <span class="number">335</span>  <span class="number">328</span>  <span class="number">322</span>  <span class="number">315</span>  <span class="number">309</span>  <span class="number">303</span>  <span class="number">297</span>  <span class="number">290</span>  <span class="number">284</span>  <span class="number">278</span>  <span class="number">272</span>  <span class="number">267</span>  <span class="number">261</span>  <span class="number">255</span>  <span class="number">250</span>  <span class="number">244</span>  <span class="number">239</span>  <span class="number">233</span>  <span class="number">228</span>  <span class="number">223</span>  <span class="number">218</span>  <span class="number">213</span>  <span class="number">208</span>  <span class="number">203</span>  <span class="number">198</span>  <span class="number">193</span>  <span class="number">189</span>  <span class="number">184</span>  <span class="number">180</span>  <span class="number">175</span>  <span class="number">171</span>  <span class="number">167</span>  <span class="number">163</span>  <span class="number">159</span>  <span class="number">155</span>  <span class="number">151</span>  <span class="number">147</span>  <span class="number">143</span>  <span class="number">139</span>  <span class="number">136</span>  <span class="number">132</span>  <span class="number">129</span>  <span class="number">125</span>  <span class="number">122</span>  <span class="number">118</span>  <span class="number">115</span>  <span class="number">112</span>  <span class="number">109</span>  <span class="number">106</span>  <span class="number">103</span>  <span class="number">100</span>   <span class="number">97</span>   <span class="number">95</span>   <span class="number">92</span>   <span class="number">89</span>   <span class="number">87</span>   <span class="number">84</span>   <span class="number">82</span>   <span class="number">79</span>   <span class="number">77</span>   <span class="number">75</span>   <span class="number">72</span>   <span class="number">70</span>   <span class="number">68</span>   <span class="number">66</span>   <span class="number">64</span>   <span class="number">62</span>   <span class="number">60</span>   <span class="number">58</span>   <span class="number">56</span>   <span class="number">55</span>   <span class="number">53</span>   <span class="number">51</span>   <span class="number">50</span>   <span class="number">48</span>   <span class="number">46</span>   <span class="number">45</span>   <span class="number">43</span>   <span class="number">42</span>   <span class="number">41</span>   <span class="number">39</span>   <span class="number">38</span>   <span class="number">37</span>   <span class="number">36</span>   <span class="number">34</span>   <span class="number">33</span>   <span class="number">32</span>   <span class="number">31</span>   <span class="number">30</span>   <span class="number">29</span>   <span class="number">28</span>   <span class="number">27</span>   <span class="number">26</span>   <span class="number">25</span>   <span class="number">24</span>   <span class="number">23</span>   <span class="number">22</span>   <span class="number">22</span>   <span class="number">21</span>   <span class="number">20</span>   <span class="number">19</span>   <span class="number">19</span>   <span class="number">18</span>   <span class="number">17</span>   <span class="number">17</span>   <span class="number">16</span>   <span class="number">15</span>   <span class="number">15</span>   <span class="number">14</span>   <span class="number">14</span>   <span class="number">13</span>   <span class="number">13</span>   <span class="number">12</span>   <span class="number">12</span>   <span class="number">11</span>   <span class="number">11</span>   <span class="number">10</span>   <span class="number">10</span>   <span class="number">10</span>    <span class="number">9</span>    <span class="number">9</span>    <span class="number">8</span>    <span class="number">8</span>    <span class="number">8</span>    <span class="number">8</span>    <span class="number">7</span>    <span class="number">7</span>    <span class="number">7</span>    <span class="number">6</span>    <span class="number">6</span>    <span class="number">6</span>    <span class="number">6</span>    <span class="number">5</span>    <span class="number">5</span>    <span class="number">5</span>    <span class="number">5</span>    <span class="number">5</span>    <span class="number">4</span>    <span class="number">4</span>    <span class="number">4</span>    <span class="number">4</span>    <span class="number">4</span>    <span class="number">3</span>    <span class="number">3</span> ];</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(x, y);</span><br><span class="line">title(<span class="string">'gauss curve, \sigma = 75, first point norm to 1024'</span>);</span><br><span class="line"><span class="comment">% plot(x, y, x, LUT);</span></span><br><span class="line">d = y - LUT;</span><br><span class="line"><span class="built_in">max</span>(<span class="built_in">abs</span>(d))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = <span class="number">0</span>:<span class="number">8</span>:<span class="number">256</span>;</span><br><span class="line">y = normpdf(x, <span class="number">0</span>, <span class="number">80</span>);</span><br><span class="line">y = (y / y(<span class="number">1</span>) * <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">LUT = [  <span class="number">128</span>  <span class="number">128</span>  <span class="number">126</span>  <span class="number">123</span>  <span class="number">119</span>  <span class="number">115</span>  <span class="number">109</span>  <span class="number">102</span>   <span class="number">95</span>   <span class="number">89</span>   <span class="number">81</span>   <span class="number">74</span>   <span class="number">66</span>   <span class="number">59</span>   <span class="number">52</span>   <span class="number">45</span>   <span class="number">39</span>   <span class="number">34</span>   <span class="number">29</span>   <span class="number">24</span>   <span class="number">20</span>   <span class="number">17</span>   <span class="number">14</span>   <span class="number">11</span>    <span class="number">9</span>    <span class="number">7</span>    <span class="number">6</span>    <span class="number">5</span>    <span class="number">3</span>    <span class="number">3</span>    <span class="number">2</span>    <span class="number">2</span>    <span class="number">1</span>  ];</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">'b'</span>, x, LUT, <span class="string">'r'</span>);</span><br><span class="line">d = y - LUT;</span><br><span class="line"><span class="built_in">max</span>(<span class="built_in">abs</span>(d))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有一段代码是利用高斯函数来做曲线拟合的，比较简单和方便，调试起来可能也会简单些。首先利用高斯函数生成0~256之间的sigma为75的曲线，第一个点按照1024归一化。大致如下&lt;br&gt;&lt;img src=&quot;/2019/05/07/曲线调整/2019-05-07-23-33-3</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C、C++基础</title>
    <link href="http://yoursite.com/2019/05/06/C%E3%80%81C++%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/05/06/C%E3%80%81C++%E5%9F%BA%E7%A1%80/</id>
    <published>2019-05-06T14:52:46.000Z</published>
    <updated>2021-12-12T17:27:14.380Z</updated>
    
    <content type="html"><![CDATA[<p>工作中的工程主要是C，不过公共的库函数设计上面存在一些问题，例如全局变量设计不合适、函数声明不合理、部分函数定义有问题，导致可移植性有点差，改成cpp文件后，报了很多错误，这里记录一些容易错误的地方，也顺带回顾一下基础知识。</p><hr><h3 id="全局变量的声明和使用（跨文件）"><a href="#全局变量的声明和使用（跨文件）" class="headerlink" title="全局变量的声明和使用（跨文件）"></a>全局变量的声明和使用（跨文件）</h3><ul><li><a href="https://stackoverflow.com/questions/1433204/how-do-i-use-extern-to-share-variables-between-source-files" target="_blank" rel="noopener">How do I use extern to share variables between source files?</a></li><li><a href="https://stackoverflow.com/questions/1410563/what-is-the-difference-between-a-definition-and-a-declaration" target="_blank" rel="noopener">What is the difference between a definition and a declaration?</a></li></ul><p>错误的参考</p><ul><li><a href="https://blog.csdn.net/flyingdust21/article/details/51679943" target="_blank" rel="noopener">C语言：全局变量在多个c文件中公用的方法</a></li></ul><p>上面的链接中Jonathan Leffler已经回答的很好了。对于声明和定义来说：</p><ul><li>一个变量被声明是指告知编译器，有个某种类型的变量会被使用，但编译不会为它分配内存。</li><li>一个变量并定义是指编译器会分配对应变量的存储空间。</li></ul><p>一个变量可以被多次声明，但在给定的作用域范围内只能定义一次。一个变量的定义可以是一种声明，反之不是。</p><p>最佳实践方式是使用包含<code>extern</code>关键字的头文件来声明变量，然后用某个包含该头文件的源文件对该变量进行定义。</p><p>指导原则：</p><ul><li>头文件中值包含<code>extern</code>方式声明的变量，不要使用<code>static</code>或其他不合格的定义（静态全局变量只在本地文件中可以访问，因此有多个副本）</li><li>对于任何变量，仅在一个头文件中声明（SPOT-Single Point of Truth）</li><li>不要在在源文件中使用<code>extern</code>方式声明变量，源文件中应该用include头文件的方式来声明他们。——我司的实践规范，但实际代码并没有这么遵循，这样代码不好维护。</li><li>对于任何变量，只能有一个源文件进行定义，并且建议初始化为0。</li><li>头文件和源文件中的声明和定义应该保持一致。</li><li>不需要在函数中用<code>extern</code>来声明变量。</li><li>尽量避免全局变量。</li></ul><p>例如有<code>file3.h</code>、<code>file1.c</code>和<code>file2.c</code>三个文件（头文件和源文件名称一致会更好）：</p><p><strong>file3.h</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> global_variable;  <span class="comment">/* Declaration of the variable */</span></span><br></pre></td></tr></table></figure><p><strong>file1.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"file3.h"</span>  <span class="comment">/* Declaration made available here */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"prog1.h"</span>  <span class="comment">/* Function declarations */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Variable defined here */</span></span><br><span class="line"><span class="keyword">int</span> global_variable = <span class="number">37</span>;    <span class="comment">/* Definition checked against declaration */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">increment</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">return</span> global_variable++; &#125;</span><br></pre></td></tr></table></figure><p><strong>file2.c</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"file3.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"prog1.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_it</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Global variable: %d\n"</span>, global_variable++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;工作中的工程主要是C，不过公共的库函数设计上面存在一些问题，例如全局变量设计不合适、函数声明不合理、部分函数定义有问题，导致可移植性有点差，改成cpp文件后，报了很多错误，这里记录一些容易错误的地方，也顺带回顾一下基础知识。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;全局变量的声明</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Qt资源汇总</title>
    <link href="http://yoursite.com/2019/05/04/Qt%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2019/05/04/Qt%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/</id>
    <published>2019-05-04T15:14:42.000Z</published>
    <updated>2021-12-12T17:27:14.391Z</updated>
    
    <content type="html"><![CDATA[<p>最近在工作中使用到Qt，所以准备复习一下Qt相关的东西，网络上关于Qt的东西还是比较杂，仅仅记录下目前看到可能会实用的东西，同时按照自己的方式整理下，便于后续深入了解。</p><p>ref:</p><ol><li><a href="https://blog.csdn.net/liang19890820/article/details/51752029" target="_blank" rel="noopener">Qt 资料大全 CSDN</a></li></ol><h2 id="Qt官网"><a href="#Qt官网" class="headerlink" title="Qt官网"></a>Qt官网</h2><ul><li><a href="https://www.qt.io/" target="_blank" rel="noopener">Qt官网</a></li><li><a href="https://www.qt.io/download" target="_blank" rel="noopener">Qt下载</a> Qt源码也在这里面下载</li><li><a href="http://download.qt.io/archive/qt/" target="_blank" rel="noopener">Qt所有版本下载</a></li><li><a href="http://download.qt.io/official_releases/qt" target="_blank" rel="noopener">Qt官方发布下载</a></li><li><a href="https://wiki.qt.io/Main" target="_blank" rel="noopener">Qt wiki</a></li></ul><h2 id="Github-amp-Third-Party"><a href="#Github-amp-Third-Party" class="headerlink" title="Github &amp; Third-Party"></a>Github &amp; Third-Party</h2><ul><li><a href="https://github.com/qtproject" target="_blank" rel="noopener">Qt Project github</a> 官方镜像，各种强大的Qt项目及丰富的Qt库</li><li><a href="https://insideqt.github.io/awesome-qt/" target="_blank" rel="noopener">Awesome Qt</a></li><li><a href="https://github.com/fffaraz/awesome-cpp" target="_blank" rel="noopener">Awesome C++</a>/[]</li><li><a href="https://inqlude.org/" target="_blank" rel="noopener">inqlude</a> Qt库存档</li><li><a href="https://github.com/justjavac/free-programming-books-zh_CN" target="_blank" rel="noopener">免费的编程中文书籍索引</a></li></ul><h2 id="社区论坛"><a href="#社区论坛" class="headerlink" title="社区论坛"></a>社区论坛</h2><h3 id="国外"><a href="#国外" class="headerlink" title="国外"></a>国外</h3><ul><li><a href="http://www.qtcentre.org" target="_blank" rel="noopener">Qt-Centre</a> 很全面的国外网站，包含forum、wiki、docs和blogs等</li><li><a href="https://forum.qt.io/" target="_blank" rel="noopener">Qt-forum</a> 知名的Qt论坛</li><li><a href="https://www.linux-apps.com/" target="_blank" rel="noopener">Linux-Apps</a> 可以找到很多免费的 Qt 应用，获得源码来学习、研究。</li><li><a href="https://www.qtsoftware.de/oxShop2/source/" target="_blank" rel="noopener">Qt Software</a> 提供第三方商业软件和开源软件的Qt用户社区</li><li><a href="http://quitcoding.com/" target="_blank" rel="noopener">QUIt Coding</a></li></ul><h3 id="国内"><a href="#国内" class="headerlink" title="国内"></a>国内</h3><ul><li><a href="https://bbs.csdn.net/forums/Qt" target="_blank" rel="noopener">Qt论坛 CSDN</a></li><li><a href="http://www.qtcn.org/bbs/i.php" target="_blank" rel="noopener">QTCN 开发网 </a></li><li><a href="http://www.qter.org" target="_blank" rel="noopener">Qter 开源社区 </a> 里面富含 Qter 们开发的实用开源项目和作品，以及一系列优秀的原创教程 - 图文并茂、简单易学</li></ul><h2 id="blog"><a href="#blog" class="headerlink" title="blog"></a>blog</h2><ul><li><a href="http://planet.qt.io/" target="_blank" rel="noopener">Qt 相关博客的汇集者</a></li><li><a href="http://blog.csdn.net/liang19890820" target="_blank" rel="noopener">一去丶二三里</a></li><li><a href="http://www.devbean.net" target="_blank" rel="noopener">豆子</a></li><li><a href="https://blog.csdn.net/dbzhang800" target="_blank" rel="noopener">1+1=10</a></li><li><a href="http://qtdebug.com/" target="_blank" rel="noopener">QtDebug</a></li></ul><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ul><li>QmlBook - A Book about Qt5<ul><li><a href="http://qmlbook.github.io" target="_blank" rel="noopener">英文版</a></li><li><a href="https://github.com/cwc1987/QmlBook-In-Chinese" target="_blank" rel="noopener">中文版</a></li></ul></li><li>C++ Primer</li><li>C++ GUI Qt4编程<br>Trolltech 的 Qt 培训教材，生动、全面、深刻地阐明了 Qt 程序的设计理念，轻松创建跨平台的解决方案。</li><li>Qt 高级编程<br>阐述 Qt 高级编程技术的书籍。以工程实践为主旨，是对 Qt 现有的 700 多个类和上百万字参考文档中部分关键技术深入、全面的讲解和探讨。</li><li>Python Qt GUI 快速编程<br>讲述如何利用 Python 和 Qt 开发 GUI 应用程序的原理、方法和关键技术。结构合理，内容详实，适合用作对Python、Qt 和 PyQt 编程感兴趣的童鞋。</li><li>C++ Qt 设计模式<br>利用跨平台开源软件开发框架 Qt 阐释了 C++ 和设计模式中的主要思想，既复习了设计模式，又学了 C++/Qt，对于使用其它框架也是一个非常有用的参考。</li><li>Qt5 开发实战<br>在全面阐述 Qt 基本功能的基础上，对新增的功能和服务进行了重点介绍。同时运用大量示例，集中讲解了应用程序的开发方法、技巧和必需的 API。</li><li><strong>Qt5 开发及实例</strong><br>以 Qt5.4 为平台，循序渐进，在介绍开发环境的基础上，系统介绍 Qt5 应用程序的开发技术，通过实例介绍和讲解内容，将知识和能力融为一体。一般能够在比较短的时间内掌握 Qt5 应用技术。</li><li>Qt on Android 核心编程<br>基于 Qt 5.2，详细讲述如何在移动平台 Android 上使用 Qt 框架进行开发。无论是专注于传统的桌面软件开发，还是希望尝试使用 Qt 在 Android 平台开发，都可以从中获得重要的知识与实例。</li><li>Qt Quick 核心编程<br>着力于 QML 语言基础、事件、Qt Quick 基本元素，辅以简要的 ECMAScript（JavaScript）语言介绍，能够快速熟悉 Qt Quick 的基本知识和开发过程，详尽入微。</li><li>Qt Creator快速入门<br>基于 Qt Creator 编写，全面涉及 Qt Quick；植根于 Qt 网络博客教程，可无限更新；对每个知识点详尽讲解，并设计了示例程序。</li><li>Qt5 编程入门<br>基于 Qt5.3 编写，全面涉及 Qt Quick；植根于 Qt 网络博客教程，可无限更新；对每个知识点详尽讲解，并设计了示例程序。</li><li>Qt 5.9 C++开发指南<br><a href="https://blog.csdn.net/HongAndYi/article/details/80169184" target="_blank" rel="noopener">倾心倾力之作《Qt 5.9 C++开发指南》</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在工作中使用到Qt，所以准备复习一下Qt相关的东西，网络上关于Qt的东西还是比较杂，仅仅记录下目前看到可能会实用的东西，同时按照自己的方式整理下，便于后续深入了解。&lt;/p&gt;
&lt;p&gt;ref:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>qt小结</title>
    <link href="http://yoursite.com/2019/05/02/qt%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2019/05/02/qt%E5%B0%8F%E7%BB%93/</id>
    <published>2019-05-02T13:52:42.000Z</published>
    <updated>2021-12-12T17:27:14.400Z</updated>
    
    <content type="html"><![CDATA[<p>重新温习一下Qt的教程，回顾下相关知识</p><ul><li><a href="http://www.qter.org/portal.php?mod=view&amp;aid=25&amp;page=1" target="_blank" rel="noopener">第1篇 Qt5基础（一）Qt开发环境的搭建和hello world</a></li><li><a href="http://www.qter.org/forum.php?mod=viewthread&amp;tid=193" target="_blank" rel="noopener">Qt快速入门系列教程目录</a></li><li></li></ul><h2 id="Qt开发环境的搭建和helloworld"><a href="#Qt开发环境的搭建和helloworld" class="headerlink" title="Qt开发环境的搭建和helloworld"></a>Qt开发环境的搭建和helloworld</h2><ol><li>release版本</li><li>配置icon</li></ol><h2 id="Qt多窗口程序"><a href="#Qt多窗口程序" class="headerlink" title="Qt多窗口程序"></a>Qt多窗口程序</h2><ol><li>在界面上显示的中文仍然使用tr(“中文”)，便于使用Qt预言家来翻译整个软件要显示的字符创。</li><li>通过UI来设置信号和槽</li><li>在QtDesigner界面可以设置信号和槽</li><li>QMessageBox</li><li>lineEdit设置占位符</li><li>lineEdit的trim和clear</li><li>类的前置声明</li></ol><p>设置信号和槽的方式：</p><ol><li>F4拖动</li><li>右键转到槽，会要求选择信号</li><li>QtDesigner中选择加号</li><li>纯代码设置</li></ol><h2 id="添加菜单图标"><a href="#添加菜单图标" class="headerlink" title="添加菜单图标"></a>添加菜单图标</h2><ol><li>菜单如果方无法输入中文，可以复制和粘贴</li><li>添加资源文件<ol><li>避免外部文件的问题</li><li>压缩</li></ol></li><li>菜单栏、菜单项</li></ol><h2 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h2><ol><li>QSplitter</li><li>Vertical Layout</li></ol><h2 id="实现Qt文本编辑功能"><a href="#实现Qt文本编辑功能" class="headerlink" title="实现Qt文本编辑功能"></a>实现Qt文本编辑功能</h2><p>实现新建、保存和另存为三个功能</p><h2 id="实现Qt文本查找功能"><a href="#实现Qt文本查找功能" class="headerlink" title="实现Qt文本查找功能"></a>实现Qt文本查找功能</h2><ol><li>dialog添加layout布局</li><li>refactor功能，在.h中添加声明，然后直接在.cpp中实现定义</li><li><p>%1作为占位符，在显示时会被arg()中的参数替换掉</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QMessageBox::warning(<span class="keyword">this</span>, tr(<span class="string">"查找"</span>),</span><br><span class="line">        tr(<span class="string">"找不到%1"</span>).arg(str));</span><br></pre></td></tr></table></figure></li><li><p>文件定位方法，使用定位器。</p></li></ol><h2 id="设置主窗口状态栏"><a href="#设置主窗口状态栏" class="headerlink" title="设置主窗口状态栏"></a>设置主窗口状态栏</h2><ol><li>添加动作状态提示statusTip</li><li>显示其他临时信息</li></ol><h2 id="Qt键盘、鼠标事件的处理"><a href="#Qt键盘、鼠标事件的处理" class="headerlink" title="Qt键盘、鼠标事件的处理"></a>Qt键盘、鼠标事件的处理</h2><h2 id="Qt定时器和随机数"><a href="#Qt定时器和随机数" class="headerlink" title="Qt定时器和随机数"></a>Qt定时器和随机数</h2><p>定时器，一种是定时器事件，另一种是使用信号和槽。一般使用了多个定时器时最好使用定时器事件来处理。</p><h2 id="2D绘图"><a href="#2D绘图" class="headerlink" title="2D绘图"></a>2D绘图</h2><h3 id="渐变填充"><a href="#渐变填充" class="headerlink" title="渐变填充"></a>渐变填充</h3><h3 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h3><h3 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h3><h3 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h3><p>QImage、QPixmap、QBitmap和QPicture，它们都是常用的绘图设备。其中QImage主要用来进行I/O处理，它对I/O处理操作进行了优化，而且可以用来直接访问和操作像素；QPixmap主要用来在屏幕上显示图像，它对在屏幕上显示图像进行了优化；QBitmap是QPixmap的子类，用来处理颜色深度为1的图像，即只能显示黑白两种颜色；QPicture用来记录并重演QPainter命令。</p><p>QPixmap 缩放、旋转、扭曲等</p><h3 id="Qt坐标系统"><a href="#Qt坐标系统" class="headerlink" title="Qt坐标系统"></a>Qt坐标系统</h3><h3 id="双缓冲绘图"><a href="#双缓冲绘图" class="headerlink" title="双缓冲绘图"></a>双缓冲绘图</h3><p>这一部分并没有完成，源代码也没有正确运行，如果默认都有双缓冲的话，那一开始的代码是怎么回事。</p><h3 id="2D绘图部分窗口、视口的研究"><a href="#2D绘图部分窗口、视口的研究" class="headerlink" title="2D绘图部分窗口、视口的研究"></a>2D绘图部分窗口、视口的研究</h3><p>图形视图提供大量定制的2D图形项进行管理和相互作用，便于控制多个图形以及之间的相互作用。主要包括Scene、View和Item。</p><p>QDrag<br>QMineData<br>QCursor</p><h2 id="数据库-SQL模块"><a href="#数据库-SQL模块" class="headerlink" title="数据库 SQL模块"></a>数据库 SQL模块</h2><p>这一部分目前涉及比较少，暂时不深入研究</p><p>该模块可以分为</p><ul><li>用户接口层：用户接口层的几个类实现了将数据库中的数据链接到窗口部件上，它们是更高层次的抽象，即便不熟悉SQL也可以操作数据库<br>QSqlQueryModel、QSqlTableModel和QSqlRelationalTableModel</li><li>SQL接口层：SQL接口层提供了对数据库的访问<br>QSqlDatabase、QSqlQuery、A=QSqlError、QSqlField、QSqlIndex和QSqlRecord</li><li>驱动层：驱动层为具体的数据库和SQL接口层之间提供了底层的桥梁<br>QSqlDriver、QSqlDriverCreator、SQqlDriverCraetorBase、QSqlDriverPlugin和QSqlResult</li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h3 id="安装MySQL数据库"><a href="#安装MySQL数据库" class="headerlink" title="安装MySQL数据库"></a>安装MySQL数据库</h3><h3 id="利用QSqlQuery类执行SQL语句"><a href="#利用QSqlQuery类执行SQL语句" class="headerlink" title="利用QSqlQuery类执行SQL语句"></a>利用QSqlQuery类执行SQL语句</h3><p>有界面和按钮之间的信号和槽控制</p><ol><li>创建</li><li>操作结果</li><li>使用变量</li><li>批处理</li><li>事务操作：保证一个复杂的操作的原子性就是对于一个数据库操作序列，这些操作要么全部做完，要么一条也不做，它是一个不可分割的工作单位。</li></ol><h3 id="SQL查询模型QSqlQueryModel"><a href="#SQL查询模型QSqlQueryModel" class="headerlink" title="SQL查询模型QSqlQueryModel"></a>SQL查询模型QSqlQueryModel</h3><p>简单操作和自定义（读写）</p><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><ol><li>使用DOM读取XML文档</li><li>使用DOM创建和操作XML文档，包含UI操控</li><li>Qt中的SAX，另一种读取XML文档的方法，速度更快</li><li>使用流读写XML：QXmlStreamReader和QXmlStreamWriter，是SAX地替代品</li></ol><p>总的来说，QT提供了3种读取XML文档的方法：</p><ol><li>QXmlStreamReader：一种快速的基于流的方式访问XML文档，特别使用于一次解析</li><li>DOM（Document Object Model）：将整个XML文档读入内存，构建一个树结构，允许程序在树上向前向后移动导航，可以允许多次解析。</li><li>SAX（Simple API for XML）：提供大量虚函数，以事件的形式处理XML，是为了解决DOM得到内存占用问题提出的。</li></ol><p>生成XML文档方法：</p><ol><li>QXmlStreamWriter：最快最方便的XML方法</li><li>DOM，首先在内存中生成DOM树，然后将DOM树写入文件，临时生成树再写入比较麻烦。</li><li>手动生成XML</li></ol><h2 id="Qt元对象和属性系统"><a href="#Qt元对象和属性系统" class="headerlink" title="Qt元对象和属性系统"></a>Qt元对象和属性系统</h2><p>Qt 的元对象系统（Meta-Object System）提供了对象之间通信的信号与槽机制、运行时类型信息和动态属性系统。</p><p>元对象系统由以下三个基础组成：</p><ol><li>QObject 类是所有使用元对象系统的类的基类。</li><li>在一个类的 private 部分声明 Q_OBJECT宏，使得类可以使用元对象的特性，如动态属性、信号与槽。</li><li>MOC（元对象编译器）为每个 QObject 的子类提供必要的代码来实现元对象系统的特性。</li></ol><h2 id="Qt中的基本数据类型"><a href="#Qt中的基本数据类型" class="headerlink" title="Qt中的基本数据类型"></a>Qt中的基本数据类型</h2><ul><li><a href="https://blog.csdn.net/qq_15647227/article/details/83956078" target="_blank" rel="noopener">QT基本数据类型</a></li></ul><h2 id="编译时遇到的一些错误"><a href="#编译时遇到的一些错误" class="headerlink" title="编译时遇到的一些错误"></a>编译时遇到的一些错误</h2><ul><li><a href="https://blog.csdn.net/qq_35488967/article/details/72847088" target="_blank" rel="noopener">error LNK2001: 无法解析的外部符号 “public: virtual struct QMetaObject const * __thiscall Widget::metaObject</a></li></ul><h2 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h2><ul><li><a href="https://www.cnblogs.com/mushroom/p/5701330.html" target="_blank" rel="noopener">qt5中信号和槽的新语法 cnblogs</a></li><li><a href="https://wiki.qt.io/New_Signal_Slot_Syntax" target="_blank" rel="noopener">New Signal Slot Syntax</a></li><li><a href="https://www.cnblogs.com/wanghui1234/p/8964968.html" target="_blank" rel="noopener">C++_之Qt的信号和槽的详解 cnblogs</a></li><li><a href="https://blog.csdn.net/u012372584/article/details/88252002" target="_blank" rel="noopener">QT实现信号与槽之间传递QVector类型的数据 CSDN</a> 可以不用这么麻烦</li><li><a href="https://blog.csdn.net/zhenguo26/article/details/82588415" target="_blank" rel="noopener">QT子线程与主线程的信号槽通信</a> 传结构体</li><li><a href="https://stackoverflow.com/questions/10719553/passing-qvectorfloat-from-worker-thread-to-main-thread-via-signal-slot" target="_blank" rel="noopener">Passing QVector<float> from worker thread to main thread via signal/slot</float></a> 传QVector</li><li><a href="https://blog.csdn.net/dbzhang800/article/details/6547196" target="_blank" rel="noopener">信号与槽的新语法(Qt5) CSDN</a></li><li><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></li></ul><p>所谓信号槽，实际就是观察者模式。<strong>当某个事件发生之后</strong>，比如，按钮检测到自己被点击了一下，<strong>它就会发出一个信号（signal）</strong>。这种发出是没有目的的，类似广播。<strong>如果有对象对这个信号感兴趣，它就会使用连接（connect）函数</strong>，意思是，<strong>将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号</strong>。也就是说，<strong>当信号发出时，被连接的槽函数会自动被回调</strong>。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。<br><strong>信号和槽是Qt特有的信息传输机制，是Qt设计程序的重要基础，它可以让互不干扰的对象建立一种联系。</strong><br>槽的本质是类的成员函数，其参数可以是任意类型的。和普通C++成员函数几乎没有区别，它可以是虚函数；也可以被重载；可以是公有的、保护的、私有的、也可以被其他C++成员函数调用。唯一区别的是：<strong>槽可以与信号连接在一起，每当和槽连接的信号被发射的时候，就会调用这个槽。</strong>Qt5中的新语法可以将信号connect到QObject的任何成员方法，不仅仅是定义的槽。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>Qt5中的使用方式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">"Quit"</span>)</span></span>;</span><br><span class="line">    QObject::connect(&amp;button, &amp;QPushButton::clicked,</span><br><span class="line">                    &amp;app, &amp;QApplication::quit);</span><br><span class="line">    button.show();</span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>connect()函数最常用的一般形式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">connect(sender, signal, receiver, slot);</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>sender：发出信号的对象</li><li>signal：发送对象发出的信号</li><li>receiver：接收信号的对象</li><li>slot：接收对象在接收到信号之后所需要调用的函数</li></ul><p><strong>信号槽要求信号和槽的参数一致，所谓一致，是参数类型一致</strong>。如果不一致，<strong>允许的情况是，槽函数的参数可以比信号的少，即便如此，槽函数存在的那些参数的顺序也必须和信号的前面几个一致起来。</strong>这是因为，你可以在槽函数中选择忽略信号传来的数据（也就是槽函数的参数比信号的少），但是不能说信号根本没有这个数据，你就要在槽函数中使用（就是槽函数的参数比信号的多，这是不允许的）。</p><p>Qt4的使用方式：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">        QPushButton *button = <span class="keyword">new</span> QPushButton(<span class="string">"Quit"</span>);</span><br><span class="line">        connect(button, SIGNAL(clicked()), &amp;a, SLOT(quit()));</span><br><span class="line">        button-&gt;show();</span><br><span class="line">        <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了<strong>SIGNAL</strong>和<strong>SLOT</strong>这两个宏，<strong>将两个函数名转换成了字符串</strong>。注意到connect()函数的signal和slot都是接受字符串，<strong>一旦出现连接不成功的情况，Qt4是没有编译错误的</strong>（因为一切都是字符串，编译期是不检查字符串是否匹配），<strong>而是在运行时给出错误。这无疑会增加程序的不稳定性</strong>。</p><p>Qt中使用了新的信号和槽语法，作为旧语法的一种补充。</p><p><strong>旧语法</strong><br>qt5将继续支持旧的语法去连接，在QObject对象上定义信号和槽函数，及任何继承QObjec的对象（包含QWidget）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">connect(sender, SIGNAL (valueChanged(QString,QString)),receiver, SLOT (updateValue(QString)) );</span><br></pre></td></tr></table></figure><h3 id="自定义信号和槽"><a href="#自定义信号和槽" class="headerlink" title="自定义信号和槽"></a>自定义信号和槽</h3><p>使用 Qt 的信号槽，实现一个报纸和订阅者的例子：<br>有一个报纸类Newspaper，有一个订阅者类Subscriber。Subscriber可以订阅Newspaper。这样，当Newspaper有了新的内容的时候，Subscriber可以立即得到通知。</p><p><strong>newspaper.h</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Newspaper(<span class="keyword">const</span> QString &amp; name) :</span><br><span class="line">        m_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">emit <span class="title">newPaper</span><span class="params">(m_name)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">newPaper</span><span class="params">(<span class="keyword">const</span> QString &amp;name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString m_name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>reader.h</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Reader() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receiveNewspaper</span><span class="params">(<span class="keyword">const</span> QString &amp; name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"Receives Newspaper: "</span> &lt;&lt; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>main.cpp</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"newspaper.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"reader.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Newspaper <span class="title">newspaper</span><span class="params">(<span class="string">"Newspaper A"</span>)</span></span>;</span><br><span class="line">    Reader reader;</span><br><span class="line">    QObject::connect(&amp;newspaper, &amp;Newspaper::newPaper,</span><br><span class="line">                     &amp;reader,    &amp;Reader::receiveNewspaper);</span><br><span class="line">    newspaper.send();</span><br><span class="line">    <span class="keyword">return</span> app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Newspaper类继承了QObject类。<strong>只有继承了QObject类的类，才具有信号槽的能力</strong>。所以，为了使用信号槽，必须继承QObject。凡是QObject类（不管是直接子类还是间接子类），都应该在第一行代码写上Q_OBJECT。不管是不是使用信号槽，都应该添加这个宏。<strong>这个宏的展开将为我们的类提供信号槽机制、国际化机制以及 Qt 提供的不基于 C++ RTTI 的反射能力</strong>。</p><p>Newspaper类的 public 和 private 代码块都比较简单，只不过它新加了一个 signals。signals块所列出的，就是该类的信号。<strong>信号就是一个个的函数名，返回值是void</strong>（因为无法获得信号的返回值，所以也就无需返回任何值），参数是该类需要让外界知道的数据。<strong>信号作为函数名，不需要在cpp函数中添加任何实现</strong>。</p><p>Newspaper类的send()函数比较简单，只有一个语句emit newPaper(m_name);。<strong>emit是Qt对C++的扩展，是一个关键字（其实也是一个宏）</strong>。emit的含义是发出，也就是发出newPaper()信号。感兴趣的接收者会关注这个信号，可能还需要知道是哪份报纸发出的信号？所以，<strong>我们将实际的报纸名字m_name当做参数传给这个信号。当接收者连接这个信号时，就可以通过槽函数获得实际值</strong>。这样就完成了数据从发出者到接收者的一个转移。</p><p>Reader类更简单。因为这个类需要接受信号，所以我们将其继承了QObject，并且添加了Q_OBJECT宏。后面则是默认构造函数和一个普通的成员函数。<strong>Qt5中，任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数</strong>。与信号函数不同，槽函数必须自己完成实现代码。<strong>槽函数就是普通的成员函数，因此作为成员函数，也会受到public、private 等访问控制符的影响</strong>。（<strong>如果信号是private的，这个信号就不能在类的外面连接，也就没有任何意义</strong>。）</p><p>小结：</p><ul><li>发送者和接收者都需要是QObject的子类（当然，槽函数是全局函数、Lambda 表达式等无需接收者的时候除外）；</li><li>使用 signals 标记信号函数，信号是一个函数声明，返回 void，不需要实现函数代码；</li><li>槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响；</li><li>使用 emit 在恰当的位置发送信号；</li><li>使用QObject::connect()函数连接信号和槽。</li><li>任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数</li><li>槽函数需要和信号一致（参数，返回值），由于信号都是没有返回值，所以槽函数一定没有返回值</li></ul><h3 id="信号槽的更多用法"><a href="#信号槽的更多用法" class="headerlink" title="信号槽的更多用法"></a>信号槽的更多用法</h3><ul><li>一个信号可以和多个槽相连<br>　　如果是这种情况，这些槽会一个接一个的被调用，但是它们的调用顺序是不确定的。</li><li><p>多个信号可以连接到一个槽<br>　　只要任意一个信号发出，这个槽就会被调用。</p></li><li><p>一个信号可以连接到另外的一个信号<br>　　当第一个信号发出时，第二个信号被发出。除此之外，这种信号-信号的形式和信号-槽的形式没有什么区别。</p></li><li>槽可以被取消链接<br>　　这种情况并不经常出现，因为当一个对象delete之后，Qt自动取消所有连接到这个对象上面的槽。</li><li><p>使用Lambda 表达式<br>　　在使用 Qt 5 的时候，能够支持 Qt 5 的编译器都是支持 Lambda 表达式的。<br>　　我们的代码可以写成下面这样：</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QObject::connect(&amp;newspaper, <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> (Newspaper:: *)</span><br><span class="line">(<span class="keyword">const</span> QString &amp;)&gt;(&amp;Newspaper::newPaper),</span><br><span class="line">[=](<span class="keyword">const</span> QString &amp;name)</span><br><span class="line">&#123; <span class="comment">/* Your code here. */</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>  在连接信号和槽的时候，槽函数可以使用Lambda表达式的方式进行处理。</p></li></ul><h3 id="新旧语法对比"><a href="#新旧语法对比" class="headerlink" title="新旧语法对比"></a>新旧语法对比</h3><p><strong>新语法：连接到QObject成员</strong><br>下面是一种新的方式来连接两个QObjects：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">connect(sender, &amp;Sender::valueChanged,receiver, &amp;Receiver::updateValue );</span><br></pre></td></tr></table></figure><p>它支持：</p><ul><li>编译期间检查信号和槽是否存在，它们的类型，及Q_OBJECT是否丢失</li><li>参数能被typedef或不同命名空间指定。</li><li>如果有隐式转换的参数，会自动转换类型。比如QString到QVariant</li><li>它可以连接QObject的任何成员方法，不仅仅是定义的槽。</li></ul><p>旧版本的不足原因是旧语法connect接收的是两个字符串：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">bool QObject::connect ( const QObject * sender, const char * signal, const QObject * receiver, const char * method, Qt::ConnectionType type = Qt::AutoConnection ) [static]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">connect(slider, SIGNAL(valueChanged(<span class="keyword">int</span>)), spinbox, SLOT(setValue(<span class="keyword">int</span>)));</span><br></pre></td></tr></table></figure><p>编译预处理后就是：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">connect(slider, <span class="string">"2valueChanged(int)"</span>, spinbox, <span class="string">"1setValue(int)"</span>);</span><br></pre></td></tr></table></figure><p>这将导致：</p><ul><li>即使信号和槽不存在，编译不会出问题。只有运行时会给出警告并返回false，可是大部分用户并不检查返回值。</li><li>参数必须匹配，比如信号参数是 int，槽参数是 double，语法将会 connect 失败</li><li>参数类型必须字面上一样，比如说都是int，但是其中一个typedef了一下，或者namespace修饰不同，都会导致连接失败。</li></ul><p>而在新语法中避免掉了这些问题。但它不支持：</p><ul><li>更复杂的语法？你需要指定你的对象类型、</li><li>非常复杂的语法，比如重载，参见后面。</li><li><strong>在槽的中默认参数不再被支持</strong>。</li></ul><p>很典型的例如<code>QSpinBox</code>重载了信号<code>valueChanged()</code>，因此不能将</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">connect(mySpinBox, SIGNAL(valueChanged(<span class="keyword">int</span>)), mySlider, SLOT(setValue(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><p>简单转换为</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">connect(</span><br><span class="line">    mySpinBox, &amp;QSpinBox::valueChanged,</span><br><span class="line">    mySlider, &amp;QSlider::setValue</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>需要使用强制类型转换</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">connect(</span><br><span class="line">    mySpinBox, <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> (QSpinBox::*)(<span class="keyword">int</span>)&gt;(&amp;QSpinBox::valueChanged),</span><br><span class="line">    mySlider, &amp;QSlider::setValue</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>不过这种显示转换可能还是会让某些错误跳过编译器，可以容如下赋值临时变量的方法来保持编译期的检查：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (QSpinBox::* mySignal)(<span class="keyword">int</span>) = &amp;QSpinBox::valueChanged;</span><br><span class="line">connect(</span><br><span class="line">    mySpinBox, mySignal,</span><br><span class="line">    mySlider, &amp;QSlider::setValue</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>当然还有一些其他方法，但<strong>最好就是不要重载信号和槽</strong>。</p><h3 id="传递非基本数据类型"><a href="#传递非基本数据类型" class="headerlink" title="传递非基本数据类型"></a>传递非基本数据类型</h3><p>正常情况下信号和槽只能传递通用数据类型，例如<code>QVector</code>、<code>QString</code>和结构体等不能传递，编译可能不会出错，但槽函数不会被调用，需要对复杂数据做一些包装处理才行。可以使用</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qRegisterMetaType&lt;QVector&lt;<span class="keyword">float</span>&gt; &gt;(<span class="string">"QVector&lt;float&gt;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> int_info_;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str_info;   <span class="comment">// 不知道是否还要对string再注册下</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">qRegisterMetaType&lt;Msg&gt;(<span class="string">"Msg"</span>);</span><br></pre></td></tr></table></figure><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>C++11中的Lambda表达式用于定义并创建匿名的函数对象，以简化编程工作。首先看一下Lambda表达式的基本构成：<br><img src="/2019/05/02/qt小结/2019-05-07-01-00-21.png" alt></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[函数对象参数](操作符重载函数参数)<span class="keyword">mutable</span>或exception -&gt;返回值&#123;函数体&#125;</span><br></pre></td></tr></table></figure><ol><li><p>函数对象参数；<br>　　[]，标识一个Lambda的开始，这部分必须存在，不能省略。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义Lambda为止时Lambda所在作用范围内可见的局部变量（包括Lambda所在类的this）。函数对象参数有以下形式：</p><ul><li>空。没有使用任何函数对象参数。</li><li>=。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。</li><li>&amp;。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是引用传递方式（相当于编译器自动为我们按引用传递了所有局部变量）。</li><li>this。函数体内可以使用Lambda所在类中的成员变量。</li><li>a。将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。</li><li>&amp;a。将a按引用进行传递。</li><li>a, &amp;b。将a按值进行传递，b按引用进行传递。</li><li>=，&amp;a, &amp;b。除a和b按引用进行传递外，其他参数都按值进行传递。</li><li><p>&amp;, a, b。除a和b按值进行传递外，其他参数都按引用进行传递。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">[=] (<span class="keyword">int</span> a) <span class="keyword">mutable</span> &#123; m = ++n + a; &#125;(<span class="number">4</span>);</span><br><span class="line">[&amp;] (<span class="keyword">int</span> a) &#123; m = ++n + a; &#125;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">[=,&amp;m] (<span class="keyword">int</span> a) <span class="keyword">mutable</span> &#123; m = ++n + a; &#125;(<span class="number">4</span>);</span><br><span class="line">[&amp;,m] (<span class="keyword">int</span> a) <span class="keyword">mutable</span> &#123; m = ++n + a; &#125;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">[m,n] (<span class="keyword">int</span> a) <span class="keyword">mutable</span> &#123; m = ++n + a; &#125;(<span class="number">4</span>);</span><br><span class="line">[&amp;m,&amp;n] (<span class="keyword">int</span> a) &#123; m = ++n + a; &#125;(<span class="number">4</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>操作符重载函数参数；<br> 标识重载的()操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如：(a,b)）和按引用（如：(&amp;a,&amp;b)）两种方式进行传递。</p></li><li>可修改标示符；<br> mutable声明，这部分可以省略。按值传递函数对象参数时，加上mutable修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）。</li><li>错误抛出标示符；<br> exception声明，这部分也可以省略。exception声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用throw(int)</li><li>函数返回值；<br> -&gt;返回值类型，标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。</li><li>是函数体；<br> {}，标识函数的实现，这部分不能省略，但函数体可以为空。</li></ol><pre><code>布局是QT界面当中必不可少的一环。我们常常使用QHBoxLayout、QVBoxLayout等进行布局。然而有个问题是，在MainWindow并不能直接进行布局。-[QT笔记——在QMainWindow内直接添加Layout行不通](https://blog.csdn.net/qq_26399665/article/details/52695042)发现在QMainWindow中添加的控件不显示，还有QToolBar也可能。原因是该窗口类中已经有一个Layout对象了，这时候再setLayout是无效的。有三种方法：1. 调用layout()方法，返回这个窗口内部的layout对象，删除后再setLayout设置自己的Layout对象2. 直接使用该Layout对象3. 创建子窗口对象，在这个子窗口对象中使用Layout对象。例如在QMainWindow中，通常是创建一个窗口对象后，调用setCentralWidget来安装该窗口，然后在该窗口中使用自己的Layout。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QWidget *widget = <span class="keyword">new</span> QWidget();</span><br><span class="line"><span class="comment">// method 1</span></span><br><span class="line"><span class="comment">//setCentralWidget(widget);</span></span><br><span class="line"><span class="comment">//centralWidget()-&gt;setLayout(mainLayout);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// method 2</span></span><br><span class="line">widget-&gt;setLayout(mainLayout);</span><br><span class="line">setCentralWidget(widget);</span><br></pre></td></tr></table></figure>## utilsQMessageBox::information(this, tr(&quot;Information&quot;), str);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;重新温习一下Qt的教程，回顾下相关知识&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.qter.org/portal.php?mod=view&amp;amp;aid=25&amp;amp;page=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;第</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://yoursite.com/2019/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2019-05-01T02:02:44.000Z</published>
    <updated>2021-12-12T17:27:14.414Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>OpenMP</title>
    <link href="http://yoursite.com/2019/05/01/OpenMP/"/>
    <id>http://yoursite.com/2019/05/01/OpenMP/</id>
    <published>2019-04-30T17:35:55.000Z</published>
    <updated>2021-12-12T17:27:14.381Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.it1352.com/349766.html" target="_blank" rel="noopener">如何保证动态分配的数组是私人的OpenMP(How to ensure a dynamically allocated array is private in openmp)</a></p><p><a href="http://xsk.tehon.org/den/index.php/category/tech/openmp-notes-programming.html" target="_blank" rel="noopener">OpenMP学习笔记：编程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://www.it1352.com/349766.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何保证动态分配的数组是私人的OpenMP(How to ensure a dynamically allocated ar</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SVN使用</title>
    <link href="http://yoursite.com/2019/05/01/SVN%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/05/01/SVN%E4%BD%BF%E7%94%A8/</id>
    <published>2019-04-30T17:33:49.000Z</published>
    <updated>2021-12-12T17:27:14.393Z</updated>
    
    <content type="html"><![CDATA[<p>参考<a href="https://www.cnblogs.com/linlf03/p/6923519.html" target="_blank" rel="noopener">TortoiseSVN比较工具设置为BeyondCompare 4</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考&lt;a href=&quot;https://www.cnblogs.com/linlf03/p/6923519.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TortoiseSVN比较工具设置为BeyondCompare 4&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>qwt使用</title>
    <link href="http://yoursite.com/2019/04/30/qwt%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/04/30/qwt%E4%BD%BF%E7%94%A8/</id>
    <published>2019-04-30T15:32:52.000Z</published>
    <updated>2021-12-12T17:27:14.401Z</updated>
    
    <content type="html"><![CDATA[<p>近期需要做一个调试小工具，用于可视化调试LUT，可以使用Qt的Qwt库，全称是Qt Widgets for Technical Applications，用于生成各种统计图。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官网介绍<a href="https://qwt.sourceforge.io/index.html" target="_blank" rel="noopener">Qwt User’s Guide</a></p><p>MSVC-2015 64bit的完整安装教程，<a href="https://www.qtcentre.org/threads/66576-Installing-Qwt-with-MSVC-2015-64bit-compiler-on-Windows-(complete-instructions" target="_blank" rel="noopener">Installing Qwt with MSVC-2015 64bit compiler on Windows (complete instructions)</a>)。我使用的是Qt 5.12.0。源码路径和安装路径最好分离开，便于重新再来。<br>完整以上安装后，为了方便VS使用还需要做一些简单lib、bin和include的配置。参考<a href="https://blog.csdn.net/toby54king/article/details/78852396" target="_blank" rel="noopener">QWT6.1.3编译、配置和使用（Vs2010+Qwt6.1.3+Qt5.5.1编译）</a>。</p><p>安装后的文件<br><img src="/2019/04/30/qwt使用/2019-05-01-01-00-40.png" alt></p><ol><li>对Qt的安装路径配置环境变量<br><img src="/2019/04/30/qwt使用/2019-05-01-00-57-36.png" alt></li><li>拷贝include目录到Qt的include目录，最好新建个Qwt的子目录</li><li>拷贝<strong>lib\qwt.lib</strong>和<strong>qwtd.lib</strong>到Qt的lib目录下</li><li>拷贝<strong>lib\qwt.dll</strong>和<strong>qwtd.dll</strong>到Qt的bin目录下</li><li>拷贝<strong>plugins\designer\qwt_designer_plugin.dll</strong>到<strong>plugins\designer</strong>目录下，用于qt designer。</li><li>配置VS（有些不是必须的，但最好配置上）<ol><li>配置头文件：<code>$(QTDIR)\include\Qwt</code><br><img src="/2019/04/30/qwt使用/2019-05-01-01-04-35.png" alt></li><li>配置可执行文件：<code>qwtd.lib</code>（如果是Release版本用<code>qwt.lib</code>）<br><img src="/2019/04/30/qwt使用/2019-05-01-01-05-32.png" alt></li><li>配置预处理器：QWT_DLL<br><img src="/2019/04/30/qwt使用/2019-05-01-01-08-08.png" alt></li></ol></li><li>跑提供的测试代码<a href="https://www.qtcentre.org/threads/66576-Installing-Qwt-with-MSVC-2015-64bit-compiler-on-Windows-(complete-instructions" target="_blank" rel="noopener">Installing Qwt with MSVC-2015 64bit compiler on Windows (complete instructions)</a>)<br>基本效果如下<br><img src="/2019/04/30/qwt使用/2019-05-01-01-10-16.png" alt></li></ol><p>MSVC-2017应该也有类似的教程。</p><h2 id="qwt-demo"><a href="#qwt-demo" class="headerlink" title="qwt demo"></a>qwt demo</h2><p>网络上的资源参差不齐，最好还是从官方提供的example入手，之前就是因为没有完整编译好工程导致有些demo没看到，苦苦看源码搜资料查了好久。</p><ol><li>animation</li><li>barchart：柱状图、导出按钮combox</li><li>bode：picker数据拾取器</li><li>controls：多个tab</li><li>cpuplot：legend选择可隐藏</li><li>curvdemo1</li><li>dials：多个tab</li><li>distrowatch</li><li>event_filter：曲线上鼠标拖动点</li><li>friedberg</li><li>itemeditor：editor</li><li>legends：layout设计、多个按钮控制显示</li><li>oscilloscope</li><li>radio</li><li>rasterview：放大缩小</li><li>realtime：组合控制</li><li>refreshtest</li><li>scatterplot：平移放大缩小</li><li>simpleplot：简单曲线显示</li><li>sinusplot：always picker</li><li>spectrogram</li><li>stockchart：checkbox</li><li>sysinfo</li><li>tvplot</li></ol><p>这里列几个典型的</p><p><img src="/2019/04/30/qwt使用/2019-05-01-01-59-06.png" alt><br><img src="/2019/04/30/qwt使用/2019-05-01-01-58-14.png" alt><br><img src="/2019/04/30/qwt使用/2019-05-01-01-55-00.png" alt><br><img src="/2019/04/30/qwt使用/2019-05-01-01-57-10.png" alt></p><h2 id="使用过程中一些小细节"><a href="#使用过程中一些小细节" class="headerlink" title="使用过程中一些小细节"></a>使用过程中一些小细节</h2><ol><li>按钮出现中文乱码</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码文件的字符集不是UTF8 ？</span></span><br><span class="line"><span class="comment">// 如果是Qt5.x，则：</span></span><br><span class="line">fileBtn-&gt;setText(tr(<span class="string">"文件标准对话框"</span>));</span><br><span class="line"><span class="comment">// 修改为</span></span><br><span class="line">fileBtn-&gt;setText(QStringLiteral(<span class="string">"文件标准对话框"</span>));</span><br></pre></td></tr></table></figure><ol><li>pushbutton的简单使用</li><li><a href="https://blog.csdn.net/qq_25800311/article/details/80913477" target="_blank" rel="noopener">Qt QPushButton</a></li></ol><h2 id="Qt的MVC设计模式"><a href="#Qt的MVC设计模式" class="headerlink" title="Qt的MVC设计模式"></a>Qt的MVC设计模式</h2><p>网络上关于Qt的介绍还是相对不多的，这里记录下Qt相关的东西，便于回溯。</p><h3 id="架构、框架和设计模式"><a href="#架构、框架和设计模式" class="headerlink" title="架构、框架和设计模式"></a>架构、框架和设计模式</h3><p>ref:<br><a href="https://www.cnblogs.com/the-wang/p/7258303.html" target="_blank" rel="noopener">架构、框架和设计模式</a></p><h4 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h4><p>软件架构是系统的一个草图，阐述了各个组件之间的通信，层次划分，一旦系统开始详细设计，架构蓝图就很难甚至无法改变。</p><p>例如：三层架构：一种设计软件架构的思想。</p><p>通常意义上的三层架构就是将整个业务应用划分为表示层（User Interface  Layer）、业务逻辑层（Buesiness Logic Layer）、数据访问层（Data Access Layer）。区分层次的目的是为了体现“高内聚，低耦合”的思想。</p><ol><li>表示层<br> 表示层位于最外层（最上层），最接近于用户。用于显示数据和接收用户输入的数据为用户提供一种交互式的操作界面。</li><li>业务逻辑层<br> 业务逻辑层无疑是系统架构中体现核心价值的部分。他的关注点主要集中在业务规则的制定、业务流程的实现等与业务需求相关的系统设计上，也就是说，他与系统所对应的领域（Domain）逻辑有关，很多时候，也将业务逻辑层称为领域层。<br> 业务逻辑层在体系架构中的位置很关键，他处于数据访问层与表示层中间起到了数据交换中承上启下的作用。对于数据访问层而言，他是调用者；对于表示层而言，他却是被调用者。</li><li>数据访问层<br> 数据访问层有时候也称为持久层，其功能主要是负责数据库的访问，可以访问数据库系统、二进制文件、文本文档、或是XML文档。简单的说法就是实现对数据表的Select、Insert、Update和Delete操作。</li></ol><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>软件框架是（Framework）是项目软件开发过程中提取特定领域软件的共性部分形成的体系结构，不同领域的软件项目有着不同的框架类型。<strong>框架的作用在于：由于提取了特定领域软件的共性部分，因此在此领域内新项目开发过程中代码不需要从头编写，只需要编写在框架的基础上进行一些开发和调整便可满足要求：对于开发过程而言，这样做会提高软件的质量减低成本，缩短开发时间，是的开发越做越轻松，效益越做越好，形成一种良性循环。</strong></p><p>框架不是现成可用的应用系统，<strong>他是一个半成品</strong>，需要后来的开发人员进行二次开发，实现具体功能的应用系统。框架也不是平台，平台的概念比较模糊，他可以是一种操作系统、一种应用服务器、一种数据库软件或一种通信软件等，因此平台在应用方面主要指提供特定服务的系统软件；而框架更侧重于设计和开发过程，或者可以说，框架通过调用平台提供的服务而起作用。</p><p>框架也不是工具包或者类库。望文生义，类库就是一些类的集合，只要我们将一些可以复用的类集中放到一个Library中，就可以称其为一个类库。类库中的许多元素（如：类、结构、接口、枚举等）之间可能有一些关联，但这些关联通常用于支持一个类概念或接口概念的完整表达。如果从一个更高的视角来审视类库，可以发现类库中的一个个“完整的概念”之间是无关的或是关系松散的，框架和类库有着相似的形式，即框架往往也是类的集合；但不同之处在于，<strong>框架中的各个类并不是孤立的，框架中的业务逻辑代码是将不同的类连在一起在他们之间建立协作关系</strong>，例如：Spring-一个开源的Web设计规范。</p><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><p>设计模式是对某种环境下反复出现的问题以及解决该问题的方案描述，比框架更加抽象；框架可以用代码表示，也能直接执行或复用，而对模式而言只有实例才能用代码表示;设计模式是比框架更小的元素，一个框架中往往含有一个或多个设计模式，框架总是针对某一特定应用领域，但同一模式却可适用于各种应用。</p><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ol><li>框架与设计模式<br> 框架通常是代码重用，而设计模式是设计重用，架构介于两者之间，部分代码重用部分设计重用。<br> 设计模式研究的是针对单一问题的设计思路和解决方法，一个模式可以应用于不同的框架和被不同的语言所实现；而框架则是一个应用的体系结构，是一种或多种设计模式和代码的混合体，虽然他们有所不同，但却共同致力于使人们的设计可以被重用，在思想上存在着统一性的特点，因而设计模式的思想可以在框架设计中进行应用。</li><li>框架与架构<br> 框架不是架构，框架比架构更具体，更偏重于技术，而架构偏重于设计。一个架构可以通过多种框架来实现.</li><li>架构与设计模式<br> 设计模式主要是针对单一问题的解决方法，范畴比较小，而架构是高层次的针对体系结构的一种设计思路，范畴比较大。可以说一个架构中可能会出现多个设计模式类解决架构中的多种问题。</li></ol><p>通过上面的分析，可以看出这三者之间得区别还有很多，首先架构是一个范畴最大的概念，是最高层次的设计，一个架构设计中可能会用到多个框架和多个设计模式；而框架是针对共性抽象出来的半成品，这里面可能包含着多个设计模式；而设计模式就是解决单一问题的设计思路和解决方法。</p><p>要做好一个项目，架构设计、框架设计和使用、设计模式都是非常重要的。<strong>我们在做一个项目的时候首先设计出来的应该是架构，是对整个问题的一个总体上的设计，之后再会考虑运用什么样的框架和设计模式来实现我们的框架；当然，只使用框架和设计模式中的一种也是经常遇到的。</strong></p><p>这三者的共同点都是为解决现实生活中的问题而出现的，都为了使我们的设计更面向对象化。</p><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>MVC设计模式起源于SmallTalk的一种与用户界面相关的设计模式，可以有效分离数据和用户界面。</p><p>MVC设计模式包含三个元素：<br>表示数据的模型（Model），表示用户界面的识图（View），定义了用户在界面上的操作控制（Control）。这和典型的三层架构不同。MVC是设计模式，属于微观的解决方案；三层架构是系统架构，属于宏观的解决方案。</p><h3 id="Qt的MVC——InterView框架（MVD）"><a href="#Qt的MVC——InterView框架（MVD）" class="headerlink" title="Qt的MVC——InterView框架（MVD）"></a>Qt的MVC——InterView框架（MVD）</h3><ul><li><a href="https://blog.csdn.net/weixin_39743893/article/details/80625759" target="_blank" rel="noopener">Qt的MVC设计模式——InterView框架（MVD）</a></li><li><a href="https://blog.csdn.net/u012521552/article/details/51771318" target="_blank" rel="noopener">Qt5MVC模式(一)</a></li><li><a href="https://blog.csdn.net/rl529014/article/details/52072380" target="_blank" rel="noopener">Qt中的MVC （模型/视图结构）</a></li></ul><p>与MVC设计模式类似，Qt引入了模型/视图结构用于完成数据与界面的分离，即InterView框架。但不同的是，Qt的InterView框架中把视图和控制部件结合在一起，使得框架更为简洁。<br>为了灵活地处理用户输入，InterView框架引入了代理（Delegate）。通过使用代理，能够自定义数据条目（item）的显示和编辑方式。</p><p>Qt的模型/视图结构分为了三种部分：</p><ul><li>模型（Model）</li><li>视图（View）</li><li>代理（Delegate）</li></ul><p>如下图，模型与数据通信，并为了其它部件提供接口；<br>而视图从模型中获得用来引用数据条目的模型索引（Model Index）；<br>在视图中，代理负责绘制数据条目，当编辑条目时，代理和模型直接进行通信。<br>模型/视图/代理之间通过信号和槽进行通信。</p><p><img src="/2019/04/30/qwt使用/2019-05-01-01-18-30.png" alt></p><p>它们之间的关系如下：<br>数据发生改变时，模型发出信号通知视图；<br>用户对界面进行操作，视图发生信号；<br>代理发出信号告知模型和视图编辑器目前的状态。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li>模型（Model）<br> 抽象基类QAbstractItemModel<br> 列表的抽象基类QAbstractListModel、表格的抽象基类QAbstractTableModel、QAbstractProxyModel<br> QProxyModel<br> QDirModel<br> QFileSystemModel<br> QHelpContentModel<br> QStandardItemModel类继承</li><li>视图（View）<br> 抽象基类QAbstractItemView<br> QListView—QListWidget\QUndoView<br> QTableView—QTableWidget<br> QTreeView—QTreeWidget<br> QColumnView<br> QHeaderView<br> 实际上：QListWidget、QTableWidget、QTreeWidget已经包含数据，是模型与视图集成的。</li><li>代理（Delegate）<br> 抽象基类QAbstractItemDelegate<br> QItemDelegate<br> QStyleItemDelegate<br> 类QItemDelegate由类QSqlRelationDelegate继承</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近期需要做一个调试小工具，用于可视化调试LUT，可以使用Qt的Qwt库，全称是Qt Widgets for Technical Applications，用于生成各种统计图。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>快捷键</title>
    <link href="http://yoursite.com/2019/04/30/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2019/04/30/%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2019-04-29T17:27:10.000Z</published>
    <updated>2021-12-12T17:27:14.408Z</updated>
    
    <content type="html"><![CDATA[<p>仅仅记录实际使用到的或者高频使用的，可能的不记录。</p><h2 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h2><p><a href="https://github.com/crper/Visual-Studio-Code-CNKEYMAP" target="_blank" rel="noopener">Visual-Studio-Code-CNKEYMAP</a></p><div class="table-container"><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>Alt + Click</td><td>插入多个光标</td></tr><tr><td>Alt + Shift + Click</td><td>列选（等价中键）</td></tr><tr><td>Ctrl + Alt + Down/Up</td><td>键盘列选</td></tr><tr><td>Alt + Shift + F</td><td>格式化</td></tr><tr><td>Ctrl + [ / ]</td><td>缩进</td></tr><tr><td>Ctrl + 左键文件名</td><td>vsplit一个新的编辑器</td></tr><tr><td>Ctrl + \</td><td>vsplit一个新的编辑器</td></tr><tr><td>Alt + Up/Down</td><td>上下移动一行</td></tr><tr><td>Alt + Shift + Up/Down</td><td>上下复制一行</td></tr><tr><td>Ctrl + U</td><td>删除光标左侧</td></tr><tr><td>Alt + Shift + Right</td><td>会选中匹配括号中的内容，并可以扩大选中区域</td></tr><tr><td>Ctrl + Shift + `</td><td>新建终端</td></tr></tbody></table></div><h2 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h2><div class="table-container"><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>Ctrl + U</td><td>删除光标到行首的所有字符,在某些设置下,删除全行</td></tr><tr><td>Crl + Delete</td><td>删除光标右侧</td></tr><tr><td>Ctrl + W</td><td>删除当前光标到前边的最近一个空格之间的字符</td></tr><tr><td>Ctrl + A</td><td>相当于Home</td></tr></tbody></table></div><h2 id="snipaste"><a href="#snipaste" class="headerlink" title="snipaste"></a>snipaste</h2><p>最好进行修改</p><div class="table-container"><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>Alt + F1</td><td>snip</td></tr><tr><td>Alt + F2</td><td>paste</td></tr></tbody></table></div><h2 id="Qt-Creator"><a href="#Qt-Creator" class="headerlink" title="Qt Creator"></a>Qt Creator</h2><ul><li><a href="https://blog.51cto.com/9291927/2118474" target="_blank" rel="noopener">Qt高级——QtCreator常用快捷键</a></li><li><a href="http://c.biancheng.net/view/1825.html" target="_blank" rel="noopener">Qt Creator使用技巧</a> 应该是翻译自官网的文档[]</li></ul><div class="table-container"><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td><strong>Ctrl + R</strong></td><td>运行</td></tr><tr><td>F4</td><td>QtDesigner进入信号槽的设置， 源文件和头文件之间切换</td></tr><tr><td><strong>F2</strong></td><td>转到定义</td></tr><tr><td><strong>Ctrl + I</strong></td><td>格式化代码（需先全选）</td></tr><tr><td>Ctrl + Space</td><td>代码补全</td></tr><tr><td><strong>Shift + F2</strong></td><td>声明和定义之间的跳转</td></tr><tr><td>Ctrl + B</td><td>编译工程</td></tr><tr><td>Alt + Enter</td><td>将光标移动到h文件中方法声明，添加方法实体</td></tr><tr><td>Ctrl+/</td><td>注释行，取消注释行</td></tr><tr><td>Alt + ←</td><td>后退</td></tr><tr><td>Alt + →</td><td>前进</td></tr><tr><td>Ctrl+Shift+R</td><td>Refactor\Rename Symbol Under Cursor</td></tr><tr><td>F1</td><td>查看帮助</td></tr></tbody></table></div><p>VS<br>| 快捷键       | 作用                                      |<br>| —————— | ————————————————————- |<br>| Ctrl + k, Ctrl + O| 切换头文件和源文件|</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;仅仅记录实际使用到的或者高频使用的，可能的不记录。&lt;/p&gt;
&lt;h2 id=&quot;VSCode&quot;&gt;&lt;a href=&quot;#VSCode&quot; class=&quot;headerlink&quot; title=&quot;VSCode&quot;&gt;&lt;/a&gt;VSCode&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://gith</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux使用小记</title>
    <link href="http://yoursite.com/2019/04/30/Linux%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/04/30/Linux%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/</id>
    <published>2019-04-29T16:45:45.000Z</published>
    <updated>2021-12-12T17:27:14.381Z</updated>
    
    <content type="html"><![CDATA[<p>近期需要回顾一些基础知识，需要相对系统地学习一下。</p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">Linux工具快速教程</a> 主要参考的文档</li></ul><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><ul><li>在只记得部分命令关键字的场合，我们可通过<code>man -k</code>来搜索；</li><li>需要知道某个命令的简要说明，可以使用<code>whatis</code>；用`whatis -w “loca*”实现正则匹配；</li><li>而更详细的介绍，则可用<code>info</code>命令；</li><li>查看命令在哪个位置，我们需要使用<code>which</code>；当系统中安装了同一软件的多个版本时，不确定使用的是哪个版本时，这个命令就能派上用场；</li><li>而对于命令的具体参数及使用方法，我们需要用到强大的<code>man</code>；</li></ul><p>在man的帮助手册中，将帮助文档分为了9个类别，对于有的关键字可能存在多个类别中， 我们就需要指定特定的类别来查看；（一般我们查询bash命令，归类在1类中）；</p><ol><li><strong>用户可以操作的命令或者是可执行文件</strong></li><li>系统核心可调用的函数与工具等</li><li><strong>一些常用的函数与数据库</strong></li><li>设备文件的说明</li><li>设置文件或者某些文件的格式</li><li>游戏</li><li>惯例与协议等。例如Linux标准文件系统、网络协议、ASCⅡ，码等说明内容</li><li>系统管理员可用的管理条令</li><li>与内核有关的文件</li></ol><p>我们看到printf在分类1和分类3中都有；分类1中的页面是命令操作及可执行文件的帮助；而3是常用函数库说明；如果我们想看的是C语言中printf的用法，可以指定查看分类3的帮助：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">man 3 <span class="built_in">printf</span></span><br></pre></td></tr></table></figure><h2 id="文件及目录"><a href="#文件及目录" class="headerlink" title="文件及目录"></a>文件及目录</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前目录下文件个数</span></span><br><span class="line">find ./ | wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制目录</span></span><br><span class="line">cp -r source_dir  dest_dir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到home目录</span></span><br><span class="line"><span class="built_in">cd</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按时间排序，新的在前</span></span><br><span class="line">ls -lt</span><br><span class="line">ls -ltr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给每项文件前面增加一个id编号</span></span><br><span class="line">ls | cat -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜寻文件或目录:</span></span><br><span class="line">find ./ -name <span class="string">"core*"</span> | xargs file <span class="comment"># xargs是列出文件类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找目标文件夹中是否有obj文件:</span></span><br><span class="line">find ./ -name <span class="string">'*.o'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归当前目录及子目录删除所有.o文件</span></span><br><span class="line">find ./ -name <span class="string">"*.o"</span> -<span class="built_in">exec</span> rm &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>find是实时查找，如果需要更快的查询，可试试locate；locate会为文件系统建立索引数据库，如果有文件更新，需要定期执行更新命令来更新索引库</p><p><strong>cat vi head tail more</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示时同时显示行号</span></span><br><span class="line">cat -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示文件第一行:</span></span><br><span class="line">head -1 filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示文件倒数第五行:</span></span><br><span class="line">tail -5 filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看两个文件间的差别:</span></span><br><span class="line">diff file1 file2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态显示文本最新信息:</span></span><br><span class="line">tail -f crawler.log</span><br><span class="line"></span><br><span class="line">ln cc ccAgain <span class="comment"># 硬连接；删除一个，将仍能找到；</span></span><br><span class="line">ln -s cc ccTo <span class="comment"># 符号链接(软链接)；删除源，另一个无法使用；（后面一个ccTo 为新建的文件）</span></span><br></pre></td></tr></table></figure><p>批处理命令连接执行，使用 |<br>串联: 使用分号 ;<br>前面成功，则执行后面一条，否则，不执行:&amp;&amp;<br>前面失败，则后一条执行: ||</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls /proc &amp;&amp; <span class="built_in">echo</span>  suss! || <span class="built_in">echo</span> failed.</span><br></pre></td></tr></table></figure><h3 id="查看文件夹大小"><a href="#查看文件夹大小" class="headerlink" title="查看文件夹大小"></a>查看文件夹大小</h3><p><a href="https://www.jianshu.com/p/936ae380de54" target="_blank" rel="noopener">linux下使用 du查看某个文件或目录占用磁盘空间的大小</a></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -h：以人类可读的方式显示</span></span><br><span class="line"><span class="comment"># -s：显示目录占用的磁盘空间大小，不显示其下子目录和文件占用的磁盘空间大小</span></span><br><span class="line"><span class="comment"># 查看当前目录总共占的容量。而不单独列出各子项占用的容量</span></span><br><span class="line">du -sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前路径下一级子目录的占用大小（不包含文件）</span></span><br><span class="line">du -h --max-depth=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含文件和文件夹</span></span><br><span class="line">du -ah --max-depth=1</span><br></pre></td></tr></table></figure><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>参考<a href="https://blog.csdn.net/jiangyanting2011/article/details/78875928" target="_blank" rel="noopener">Linux下的环境变量</a></p><p>Linux中环境变量包括系统级和用户级，系统级的环境变量是每个登录到系统的用户都要读取的系统变量，而用户级的环境变量则是该用户使用系统时加载的环境变量。所以管理环境变量的文件也分为系统级和用户级的。</p><ol><li>系统级<ol><li><code>/etc/environment</code>: 是系统在登录时读取的第一个文件，<strong>用于为所有进程设置环境变量。</strong></li><li><code>/etc/profile</code>：是系统登录时执行的第二个文件，可以用于设定针对全系统所有用户的环境变量。该文件一般是调用<code>/etc/bash.bashrc</code>文件。</li><li><code>/etc/bash.bashrc</code>：系统级的<code>bashrc</code>文件，为每一个运行bash shell的用户执行此文件。此文件会在用户每次打开shell时执行一次。</li></ol></li><li>用户级<ol><li><code>~/.profile</code>: 是对应当前登录用户的profile文件，用于定制当前用户的个人工作环境。 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件。</li><li><code>~/.bashrc</code>: 是对应当前登录用户的bash初始化文件，当用户每次打开shell时，系统都会执行此文件一次。平时设置这个文件就可以了。</li></ol></li></ol><p>那么根据以上描述，这几个文件的执行先后顺序应当是：<br><code>/etc/enviroment –&gt;/etc/profile –&gt;~/.profile –&gt;/etc/bash.bashrc–&gt; ~/.bashrc</code></p><p>配置环境变量</p><ol><li><p>临时生效<br> 直接运行export命令定义变量【只对当前shell(BASH)有效(临时的)】</p> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/webserver/php/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></li><li><p>对当前用户有效<br>编辑<code>~/.bashrc</code>并添加<code>export PATH=$PATH:/usr/local/webserver/php/bin</code>；用<code>source ~/.bashrc</code>让修改马上生效</p></li><li>对所有用户生效<br> 在<code>/etc/profile</code>文件中添加变量，并执行<code>source /etc/profile</code></li></ol><h2 id="文件与目录权限修改"><a href="#文件与目录权限修改" class="headerlink" title="文件与目录权限修改"></a>文件与目录权限修改</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chown <span class="comment"># 改变文件的拥有者</span></span><br><span class="line">chmod <span class="comment">#改变文件读、写、执行等属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归子目录修改</span></span><br><span class="line">chomd chown -R tuxapp <span class="built_in">source</span>/</span><br><span class="line">chown 777 -R test_dir</span><br></pre></td></tr></table></figure><p><code>chmod</code>的语法为</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chmod [who] [+ | - | =] [mode] 文件名</span><br></pre></td></tr></table></figure><ul><li>u 表示“用户（user）”，即文件或目录的所有者。</li><li>g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。</li><li>o 表示“其他（others）用户”。</li><li>a 表示“所有（all）用户”。它是系统默认值。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在一个命令行中可给出多个权限方式，其间用逗号隔开</span></span><br><span class="line">chmod g+r，o+r example <span class="comment"># 使同组和其他用户对文件example 有读权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对所有用户增加执行权限</span></span><br><span class="line">chmod a+x sort</span><br></pre></td></tr></table></figure><h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><h3 id="find-文件查找"><a href="#find-文件查找" class="headerlink" title="find 文件查找"></a>find 文件查找</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找txt和pdf文件:</span></span><br><span class="line">find . \( -name <span class="string">"*.txt"</span> -o -name <span class="string">"*.pdf"</span> \) -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则方式查找.txt和pdf:</span></span><br><span class="line"><span class="comment"># -iregex： 忽略大小写的正则</span></span><br><span class="line">find . -regex  <span class="string">".*\(\.txt|\.pdf\)$"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 否定参数 ,查找所有非txt文本:</span></span><br><span class="line">find . ! -name <span class="string">"*.txt"</span> -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定搜索深度,打印出当前目录的文件（深度为1）:</span></span><br><span class="line">find . -maxdepth 1 -<span class="built_in">type</span> f</span><br><span class="line"></span><br><span class="line"><span class="comment">## 定制搜索</span></span><br><span class="line"><span class="comment"># 按类型搜索</span></span><br><span class="line">find . -<span class="built_in">type</span> d -<span class="built_in">print</span>  //只列出所有目录</span><br><span class="line"><span class="comment"># -type f 文件 / l 符号链接 / d 目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># file命令可以检查文件具体类型（二进制或文本），find不行</span></span><br><span class="line"><span class="comment"># $ file redis-cli  # 二进制文件</span></span><br><span class="line"><span class="comment"># redis-cli: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.9, not stripped</span></span><br><span class="line"><span class="comment"># $ file redis.pid  # 文本文件</span></span><br><span class="line"><span class="comment"># redis.pid: ASCII text</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以用以下命令组合来实现查找本地目录下的所有二进制文件:</span></span><br><span class="line">ls -lrt | awk <span class="string">'&#123;print $9&#125;'</span>|xargs file|grep  ELF| awk <span class="string">'&#123;print $1&#125;'</span>|tr -d <span class="string">':'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按时间搜索</span></span><br><span class="line"><span class="comment"># -atime 访问时间 (单位是天，分钟单位则是-amin，以下类似）</span></span><br><span class="line"><span class="comment"># -mtime 修改时间 （内容被修改）</span></span><br><span class="line"><span class="comment"># -ctime 变化时间 （元数据或权限变化）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最近第7天被访问过的所有文件:</span></span><br><span class="line">find . -atime 7 -<span class="built_in">type</span> f -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最近7天内被访问过的所有文件:</span></span><br><span class="line">find . -atime -7 -<span class="built_in">type</span> f -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询7天前被访问过的所有文件:</span></span><br><span class="line">find . -atime +7 <span class="built_in">type</span> f -<span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按大小搜索</span></span><br><span class="line"><span class="comment"># w字 k M G 寻找大于2k的文件:</span></span><br><span class="line">find . -<span class="built_in">type</span> f -size +2k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除当前目录下所有的swp文件:</span></span><br><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">"*.swp"</span> -delete</span><br><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">"*.swp"</span> | xargs rm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行动作（强大的exec）</span></span><br><span class="line"><span class="comment"># 将当前目录下的所有权变更为weber:</span></span><br><span class="line">find . -<span class="built_in">type</span> f -user root -<span class="built_in">exec</span> chown weber &#123;&#125; \;</span><br><span class="line"><span class="comment"># &#123;&#125;是一个特殊的字符串，对于每一个匹配的文件，&#123;&#125;会被替换成相应的文件名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将找到的文件全都copy到另一个目录:</span></span><br><span class="line">find . -<span class="built_in">type</span> f -mtime +10 -name <span class="string">"*.txt"</span> -<span class="built_in">exec</span> cp &#123;&#125; OLD \;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要后续执行多个命令，可以将多个命令写成一个脚本。然后 -exec 调用时执行脚本即可:</span></span><br><span class="line">-<span class="built_in">exec</span> ./commands.sh &#123;&#125; \;</span><br></pre></td></tr></table></figure><h3 id="grep-文本搜索"><a href="#grep-文本搜索" class="headerlink" title="grep 文本搜索"></a>grep 文本搜索</h3><p>常用参数</p><ul><li>-o 只输出匹配的文本行 VS -v 只输出没有匹配的文本行</li><li>-c 统计文件中包含文本的次数<br>  <code>grep -c “text” filename</code></li><li>-n 打印匹配的行号</li><li>-i 搜索时忽略大小写</li><li>-l 只打印文件名</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在多级目录中对文本递归搜索(程序员搜代码的最爱）:</span></span><br><span class="line">grep <span class="string">"class"</span> . -R -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配多个模式:</span></span><br><span class="line">grep -e <span class="string">"class"</span> -e <span class="string">"vitural"</span> file</span><br></pre></td></tr></table></figure><h2 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h2><p><a href="http://www.cnblogs.com/deeryao/archive/2010/09/10/1823665.html" target="_blank" rel="noopener">linux定时关机</a></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 立刻关机</span></span><br><span class="line">shutdown -h now</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在23点定时关机</span></span><br><span class="line">shutdown -h 23:00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 延时关机sudo shutdown +minutes（这个加号不可省略，minutes表示分钟）</span></span><br><span class="line"><span class="comment"># 两小时候后关机</span></span><br><span class="line">shutdown -h +120</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消前一个关机命令按“Ctrl+C”键或输入命令：</span></span><br><span class="line">shutdown -c</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近期需要回顾一些基础知识，需要相对系统地学习一下。&lt;/p&gt;
&lt;h2 id=&quot;ref&quot;&gt;&lt;a href=&quot;#ref&quot; class=&quot;headerlink&quot; title=&quot;ref&quot;&gt;&lt;/a&gt;ref&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://linuxtools</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>A Tutorial Introduction to the Lambda Calculus</title>
    <link href="http://yoursite.com/2019/04/28/A-Tutorial-Introduction-to-the-Lambda-Calculus/"/>
    <id>http://yoursite.com/2019/04/28/A-Tutorial-Introduction-to-the-Lambda-Calculus/</id>
    <published>2019-04-27T17:10:47.000Z</published>
    <updated>2021-12-12T17:27:14.380Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://cgnail.github.io/academic/lambda-1/" target="_blank" rel="noopener">我的最爱Lambda演算——开篇</a></li><li><a href="https://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf" target="_blank" rel="noopener">A Tutorial Introduction to the Lambda Calculus</a> 很不错的一篇入门参考</li><li><a href="http://palmstroem.blogspot.com/2012/05/lambda-calculus-for-absolute-dummies.html" target="_blank" rel="noopener">The Lambda Calculus for Absolute Dummies (like myself)</a> 基本是上一篇文章的理解和翻译，不过加入了很多理解，从我看过第一篇文章后，再看这篇会很容易接受</li><li><a href="https://zhuanlan.zhihu.com/p/30510749?utm_source=ZHShareTargetIDMore&amp;utm_medium=social&amp;utm_oi=898539620818640896" target="_blank" rel="noopener">认知科学家写给小白的Lambda演算</a> 这是上一篇文章的中文翻译</li><li><a href="https://www.cs.utah.edu/~mflatt/past-courses/cs7520/public_html/s06/notes.pdf" target="_blank" rel="noopener">Programming languages and lambda calculi</a> 参考书</li><li><a href="https://zhuanlan.zhihu.com/p/25771134" target="_blank" rel="noopener">Lambda calculus引论(三): 不可判定</a> 这是更为简洁的笔记介绍</li><li><a href="https://www.jianshu.com/p/e7db2f50b012" target="_blank" rel="noopener">神奇的λ演算</a> 另一个不错的入门介绍</li></ul><p>这里以第二篇开始lambda演算的学习<br>λ演算是一种形式系统(formal system)，什么是形式系统呢？大家都知道，数学语言是可以脱离现实而存在的——大家把数学想成了一种符号游戏，脱离生活常识，从公理开始，进行大量的推导和证明——最终产生了一个系统，在这个系统中有公理、定理、推论、猜想……这种自成系统，有公理又承认推理证明方法的体系，成为形式系统。而用于描述形式系统的语言就是形式语言(formal language)</p><h2 id="图灵完备"><a href="#图灵完备" class="headerlink" title="图灵完备"></a>图灵完备</h2><p>首先先理解一下什么是<strong>图灵完备</strong>，参考知乎的答案<a href="https://www.zhihu.com/question/20115374" target="_blank" rel="noopener"># 什么是图灵完备？</a></p><h3 id="什么是图灵机"><a href="#什么是图灵机" class="headerlink" title="什么是图灵机"></a>什么是图灵机</h3><p>图灵机是图灵在1936年发表的paper中提出的数学模型，是一个架空概念，他在文中描述了什么是图灵机，并且证明，<strong>只要图灵机可以被实现，就可以用来解决任何可计算问题</strong>。<br>图灵机的结构包括：</p><ol><li>一个无限长的纸带</li><li>一个字符表</li><li>一个读写头</li><li>一个状态寄存器</li><li>一个有限的指令集</li></ol><h3 id="图灵机可以解决什么问题"><a href="#图灵机可以解决什么问题" class="headerlink" title="图灵机可以解决什么问题"></a>图灵机可以解决什么问题</h3><p>图灵证明，假设上述模型所说的功能都可以被某种形式物理实现，那么任何可计算问题都可以被解决。<br>所谓可计算问题，涉及到计算理论（即泛指一切与计算相关的问题），可以理解为，<strong>是否存在一个算法，能解决在任何输入下的此计算问题</strong>，比如著名的停机问题，就是一个不可计算的计算问题。<br>简单所，图灵证明了对于一个问题，对于任何输入，只要人类可以保证算出结果，那么图灵机就可以保证计算结果。</p><h3 id="什么是图灵完备性"><a href="#什么是图灵完备性" class="headerlink" title="什么是图灵完备性"></a>什么是图灵完备性</h3><p>图灵完备性，是针对一套数据操作规则而言的概念，数据操作规则可以是一门编程语言，也可以是计算机里的实现的指令集。当这套规则可以实现图灵机模型里的全部功能时，就称为具备图灵完备性。</p><h3 id="直观理解图灵完备——Brainfuck语言"><a href="#直观理解图灵完备——Brainfuck语言" class="headerlink" title="直观理解图灵完备——Brainfuck语言"></a>直观理解图灵完备——Brainfuck语言</h3><p>1993年，有人发明了Brainfuck语言，只有8个有效字符，每个字符都是一个指令，但这却是一门图形完备的编程语言。<br>BF的工作机制与图灵机基本一致，他存储数据的方式是一个无限长的一位整数数组，里面的数值全部初始化为0，还有一个数据指针，每个时刻都指向数组的某一元素，指针可以左右移动，也可以读取、修改数组当前元素的值。<br>BF中8个有效字符分别是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- &gt;</span><br><span class="line">指针向右移动一格</span><br><span class="line">- &lt;</span><br><span class="line">指针向左移动一格</span><br><span class="line">- +</span><br><span class="line">使指针当前格数值加一</span><br><span class="line">- -</span><br><span class="line">使指针当前格数值减一</span><br><span class="line">- .</span><br><span class="line">把当前格数值按 ASCII 表输出到终端</span><br><span class="line">- ,</span><br><span class="line">从终端接受一 byte 的数据，存储其 ASCII 数值到当前格</span><br><span class="line">- [</span><br><span class="line">当指针当前值为 0 时，程序跳转至与之对应的 ] 之后；否则程序正常执行</span><br><span class="line">- ]</span><br><span class="line">程序跳转回与之对应的 [ 处</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+++++</span><br><span class="line">[</span><br><span class="line">&gt;+++++++++++++</span><br><span class="line">&lt;-</span><br><span class="line">]</span><br><span class="line">&gt;.</span><br></pre></td></tr></table></figure><p>对于上述代码段，通过完成5X13输出了字符<code>A</code>,<br>这里讲一下我的理解，<code>+</code>进行五次，因此当前指针初始化的格子cell 0的值被递增了5次<br><code>[</code>指令读取到当前值各自值为5（因此将[]中的部分执行了5次，[]中的程序会递减该值，直到0），来看[]中的行为<br><code>&gt;</code>右移指针，随后将当前指针的各自cell 1递增了13次，再左移一个到cell 0，将cell 0的值递减一次<br>随后<code>&gt;.</code>右移指针并将当前值格子cell 1的值打印出来，得到<code>A</code></p><h3 id="图灵停机问题"><a href="#图灵停机问题" class="headerlink" title="图灵停机问题"></a>图灵停机问题</h3><p><strong>不存在有这样一个程序，能够计算任何程序在给定的输入上是否会结束（停机）。</strong><br>用反证法，假设有这样一个程序，叫做GodAlg，给定一个程序，并且给定这个程序的输入，就能够判定这个程序在这个输入上是否会停机。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GodAlg</span><span class="params">(<span class="keyword">char</span> *program, <span class="keyword">char</span> *input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (&lt;program&gt; halts on &lt;input&gt;)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们假设一个新的程序</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SatanAlg</span><span class="params">(<span class="keyword">char</span> *program)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (GodAlg(program, program)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这个算法调用自身时，SatanAlg(SatanAlg)会产生的结果如何？<br>从代码片段来看，这个程序要么能够结束运行停机，要不不能返回。</p><ol><li>假设能够停机，则if判断成立，程序进入循环，于是这个调用永远不会返回，说明SatanAlg(SatanAlg)不能停机。</li><li>假设不能够停机，则返回true，说明SatanAlg(SatanAlg)能停机。<br>这说明假设不成立，不存在这样的一个程序GodAlg</li></ol><h2 id="λ演算"><a href="#λ演算" class="headerlink" title="λ演算"></a>λ演算</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>λ演算被称为最小通用编程语言，1930年由Church引入，用于公式化有效计算中的一些问题，它也是图灵完备的，但更强调变换规则的使用，而不是具体的实现，并且其约束的规则非常简单，易于演算。<br>λ演算中只有三种表达式，分别如下。在λ演算中，只有λ和.是关键字。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- &lt;expression&gt;  := &lt;name&gt; | &lt;function&gt; | &lt;application&gt;</span><br><span class="line">- &lt;function&gt;    := λ &lt;name&gt;.&lt;expression&gt;</span><br><span class="line">- &lt;application&gt; := &lt;expression&gt;&lt;expression&gt;</span><br></pre></td></tr></table></figure><p>注意表达式可以是name，function和application，对于，在λ演算中，只有λ和.是关键字！<br>记住最后一个表达式，两个expression表示application。对于表达式，默认是从左到右进行分析或者应用应用的。</p><script type="math/tex; mode=display">E_1E_2E_3\dots E_n=(((E_1E_2)E_3)\dots E_n)</script><p>最简单的恒等函数为</p><script type="math/tex; mode=display">\lambda x.x</script><p>函数可以应用于表达式，例如下式表示将函数应用到$y$上</p><script type="math/tex; mode=display">(\lambda x.x)y</script><p>关于function application可以通过替换规则替换body中的argument实现求值，例如</p><script type="math/tex; mode=display">(\lambda x.x)y=[y/x]x=y</script><p>这里$[y/x]$表示将所有的$x$替换为$y$<br>λ演算中有α transform和β reduction，在λ演算中，变量是没有任何含义的，不代表任何东西，只是用先相同的名字表示两个相同的东西。而函数也什么都不计算，就是一个表达式，唯一能做的就是β规约(β reduction)，直到没有任何东西可以再替换为为止。</p><ul><li>α transform<br>对于λ演算中的任何表达式，可以修改函数参数的名称，只要同时修改函数体的内所有的引用。（替换有约束变量的名字）</li><li>β reduction<br>指的是，对于一个application，可以将函数体中和对应函数标识符相关的部分做替换来实现application，方法就是使用标识符作为参数值替换，也就是下面的substituions部分。（将实参应用到函数体中）</li></ul><h3 id="约束变量-bound-variable-和自由变量-free-variable-variable"><a href="#约束变量-bound-variable-和自由变量-free-variable-variable" class="headerlink" title="约束变量(bound variable)和自由变量(free variable variable)"></a>约束变量(bound variable)和自由变量(free variable variable)</h3><p><img src="https://pic2.zhimg.com/80/v2-8de07855e732abd5ff08a6c00b6a23dd_hd.jpg" alt><br>在头部(head)中提及的变量被成为约束变量，没有提到的成为自由变量，因为函数可以是其他函数的一部分，所以一个变量可以同时是约束变量，又是自由变量。</p><h3 id="substitutions"><a href="#substitutions" class="headerlink" title="substitutions"></a>substitutions</h3><p>由于在λ演算中当要使用一个函数时，都需要完整写出完整的定义，这里可以使用其他字符来代替定义，例如恒等function</p><script type="math/tex; mode=display">I= (\lambda x.x)</script><p>当恒等function应用于本身时，可以表示为</p><script type="math/tex; mode=display">II=(\lambda x.x)(\lambda x.x)</script><p>注意前后的$x$是互相独立的，上式可以写作</p><script type="math/tex; mode=display">II=(\lambda x.x)(\lambda z.z)</script><p>对上式作变量替换，将所有$x$用$\lambda z.z$替换</p><script type="math/tex; mode=display">[\lambda z.z/x] = \lambda z.z\equiv I</script><h3 id="算术"><a href="#算术" class="headerlink" title="算术"></a>算术</h3><p>λ演算最早就是应用于算术运算的，但在λ演算中只有函数，并没有所谓的数字，这里用丘齐数来表示，首先定义zero，然后one用suc(zero)表示，two用suc(suc(zero))表示。<br>zero表示为，需要接受两个参数s和z</p><script type="math/tex; mode=display">\lambda s.(\lambda z.z)</script><p>可以简写为（λ演算中只定义了单个参数的函数，但是多个参数的函数无非就是单个函数的多次调用，其实就是柯里化）</p><script type="math/tex; mode=display">0\equiv \lambda sz.z</script><p>简化后的式子可以接受两个参数，第一个可替换s，第二个可替换z。这个表达式被应用时，会把第一个表达式丢掉，然后第二个原封不动。<br>利用这个记号法，其他自然数可以定义为</p><script type="math/tex; mode=display">\begin{aligned}1 \equiv & \lambda sz.s(z) \\2 \equiv & \lambda sz.s(s(z)) \\3 \equiv &\lambda sz.s(s(s(z)))\end{aligned}</script><p>以上的计数法其实就是在z之上嵌套表达式s，数字多大就嵌套多少次，就是对z应用了n次s。这其实就是自然数的本质，不断加1。<br>我们定义后继函数(successor function)如下</p><script type="math/tex; mode=display">S =\lambda wyx.y(wyx)</script><p>后继函数可以应用于0得到</p><script type="math/tex; mode=display">\begin{aligned}S0 =& (\lambda wyx.y(wyx)) 0 \\    =& \lambda yx.y(0yx) \\    =& \lambda yx.y(x) \\    = &1\end{aligned}</script><p>同理可以得到2等等，由此即可得到加法的定义，例如2+3就表示2S3，即2 suc 3次。注意以下推导中，2接受两个参数S和3，分别将S和3作为s和z替换，同时也要注意到$S3=4$</p><script type="math/tex; mode=display">\begin{aligned}2S3\equiv & (\lambda sz.s(s(z))) S 3\\=& S(S(3))\\=& S(4) \\=& 5\end{aligned}</script><!-- 这部分有问题，需要重新看下其他文章关于加法实际可以定义如下$$+\equiv \lambda szxy.sx(ysz) \equiv \lambda sz.()$$--><h3 id="柯里化-currying"><a href="#柯里化-currying" class="headerlink" title="柯里化(currying)"></a>柯里化(currying)</h3><p>这一块可以参考wiki的解释。柯里化就是把接受多个参数的函数变成接受一个单一函数（最初函数的第一个参数）的函数，并返回接受剩余参数的函数的新函数的技术。</p><p>举个例子很典型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add(3, 5) -&gt; add(3)(5)</span><br></pre></td></tr></table></figure><p>0的定义为$\lambda sz.z$，这个其实是$\lambda s.(\lambda z.z)$是完全等价的。</p><h3 id="乘法-multiplication"><a href="#乘法-multiplication" class="headerlink" title="乘法(multiplication)"></a>乘法(multiplication)</h3><script type="math/tex; mode=display">\lambda xyz.x(yz)</script><p>例如2x2的结果为如下，注意2是可以接受两个参数的，所以$2s(z)$实际上是2接受了$s$和$z$作为输入，得到s(s(z))</p><script type="math/tex; mode=display">\begin{aligned}(\lambda xyz.x(yz))23 &= (\lambda z. 2(3z)) \\    &= \lambda z.(\lambda s.((3z)(((3z)(s))))) \\    &= \lambda zs.((3z)(3zs))\\    &= \lambda zs.3z(3zs) \\    &= \lambda zs.z(z(z(3zs))) \\    &= \lambda zs.z(z(z(z(z(z(s)))))) \\    &= 6\end{aligned}</script><p>时刻要记住每个应用函数时，接受了几个参数，并且是左结合的。</p><h2 id="条件-conditionals"><a href="#条件-conditionals" class="headerlink" title="条件(conditionals)"></a>条件(conditionals)</h2><p>定义以下两个函数为真和加，分别接受两个参数返回其中的一个，真就返回第一个，假就返回第二个</p><script type="math/tex; mode=display">\mathrm{T} \equiv \lambda xy.x \\\mathrm{F} \equiv \lambda xy.y</script><h3 id="逻辑运算-logical-operations"><a href="#逻辑运算-logical-operations" class="headerlink" title="逻辑运算(logical operations)"></a>逻辑运算(logical operations)</h3><script type="math/tex; mode=display">\land \equiv \lambda xy.xy\mathrm{F}\\\lor \equiv \lambda xy. x\mathrm{T}y \\\lnot \equiv \lambda x.x\mathrm F \mathrm T \\</script><p>例如</p><script type="math/tex; mode=display">\lnot \mathrm{T}=\mathrm T \mathrm F \mathrm T = \mathrm F</script><h3 id="条件测试-a-conditional-test"><a href="#条件测试-a-conditional-test" class="headerlink" title="条件测试(a conditional test)"></a>条件测试(a conditional test)</h3><p>定义一个函数，如果参数是数字0则返回T，否则返回F</p><script type="math/tex; mode=display">\mathrm Z \equiv \lambda x.xF\lnot F</script><p>验证如下，注意0表示接受两个参数，然后用第一个参数对第二个参数作用0次</p><script type="math/tex; mode=display">\mathrm{Z} = (\lambda x.x \mathrm F \lnot \mathrm F)0 = 0 \mathrm F \lnot \mathrm F = \lnot \mathrm F</script><script type="math/tex; mode=display">\mathrm Z \mathrm N \equiv (\lambda x.x\mathrm F \lnot \mathrm F) \mathrm N = \mathrm N \mathrm F \lnot \mathrm F</script><p><strong>注意到，F对任何参数的应用都是返回恒等函数</strong></p><script type="math/tex; mode=display">\mathrm F a \equiv (\lambda xy.y)a = \lambda y.y= \mathrm I</script><p>因此，上式继续展开为</p><script type="math/tex; mode=display">\mathrm N \mathrm F \lnot \mathrm F = \mathrm I \mathrm F =\mathrm F</script><p>另外可以换一种方式理解，$\mathrm N \mathrm F \lnot \mathrm F $同时也表示对对$\lnot $应用n次$\mathrm F$，然后结果再应用于$\mathrm F $。注意到$\mathrm F $的定义，接受两个参数，仅仅返回第二个参数。第一个$\mathrm F $实际接受了两个参数，一个是对$\lnot$应用了n-1次F的返回值，另一个是后面的一个$\mathrm F $，因此抹掉第一个参数返回第二个参数，也就是返回最后面的那个$\mathrm F $，也就是最后就返回$\mathrm F $。</p><h3 id="前继函数-predecessor-function"><a href="#前继函数-predecessor-function" class="headerlink" title="前继函数(predecessor function)"></a>前继函数(predecessor function)</h3><p>对于n的前继，通用的做法是创建一个序对(pair)，(n,n-1)然后返回需对的第二个参数作为结果。序对用λ演算可以表示为</p><script type="math/tex; mode=display">\lambda z.zab</script><p>将该函数应用于$\mathrm T$就可以返回序对的第一个数</p><script type="math/tex; mode=display">(\lambda z.zab)\mathrm T= \mathrm T ab=a</script><p>同理，应用于$\mathrm F$就可以返回需对的第二个数</p><script type="math/tex; mode=display">(\lambda z.zab)\mathrm F= \mathrm F ab=b</script><p>利用下面这个函数就可以由序对(n,n-1)生成(n+1,n-1)</p><blockquote><p>这里感觉应该是由序对(n,n-1)生成(n+1,n)才对啊！</p></blockquote><script type="math/tex; mode=display">\Theta \equiv (\lambda pz.z(S(pT))(pT))</script><blockquote><p>注意一下对上式的理解，在函数体z(S(pT))(pT))中，如果没有对z进行规约，则该式子不会进行任何计算；如果用数字n对z进行规约，变成n(S(pT))(pT)，此时才可以进一步进行参数替换S(pT)作为n的第一个参数，pT作为第二个参数。</p></blockquote><p>其中，子表达式$pT$从序对p中提取第一个元素。上式会构造一个新的序对，第一个元素是原序对第一个元素的后继——S(pT)，第二个元素就是第原序对的第一个元素——pT。</p><blockquote><p>简单来说，应该是由序对(a,b)生成(a+1,a)。</p></blockquote><p>因此n的前继就是应用n次$\Theta$到序对$\lambda z.z00$（得到(n,n-1)）然后返回第二个参数得到n-1：</p><script type="math/tex; mode=display">P\equiv \lambda n.n\Theta (\lambda z.z00)\mathrm F</script><p>可以我们可以进行推导</p><script type="math/tex; mode=display">\begin{aligned}P2=&2\Theta(\lambda z.z00)F\\=& \Theta(\Theta(\lambda z.z00))F\\=& \Theta(\Theta(\lambda p.p00))F\\=& \Theta(\lambda z.z10)F \\=& (\lambda z.z21)F\\=& F21 \\=& 1\end{aligned}</script><p>以此类推。同时要注意到$P0=0$，该性质对其他函数的定义很有用，验证如下</p><script type="math/tex; mode=display">P0=0\Theta(\lambda z.z00)F=(\lambda z.z00)F=F00=0</script><h3 id="相等与不等"><a href="#相等与不等" class="headerlink" title="相等与不等"></a>相等与不等</h3><p>定义如下函数判断数字$x$是否大于等于$y$</p><script type="math/tex; mode=display">G\equiv (\lambda xy.Z(xPy))</script><p>这里的$xPy$表示对y应用x次的前继，也就是y-x，如果该式等于0，说明$y \le x$。<br>利用$x \ge y$与$y \ge x$同时成立表示$x=y$，可以得到下面这个关于相等的定义</p><script type="math/tex; mode=display">E\equiv (\lambda xy.\land(ZxPy)(Z(yPx)))</script><p>用同样的方式我们也可以定义$x<y$，$x>y$和$x\neq y$。</y$，$x></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>在λ演算中，递归函数可以定义为调用函数y并且返回自身</p><script type="math/tex; mode=display">Y\equiv (\lambda y.(\lambda x.y(xx))(\lambda x.y(xx)))</script><p>注意这里其实是加括号了，完整表示如下</p><script type="math/tex; mode=display">Y\equiv (\lambda y.((\lambda x.y(xx))(\lambda x.y(xx))))</script><p>这里第二个$(\lambda x.y(xx))$是规约到第一个约束变量x中去的还是不会减少表达式的个数，<br>该函数应用于R时</p><script type="math/tex; mode=display">YR=(\lambda x.R(xx))(\lambda x.R(xx))= R((\lambda x.R(xx))(\lambda x.R(xx)))=R(YR)</script><p>考虑从0到n的求和函数R</p><script type="math/tex; mode=display">R\equiv (\lambda rn.Zn0(n(r(Pn))))</script><p>该函数对n进行了测试，如果n为0的话，就返回0；如果n不为0则返回n+(r(n-1))，这里r其实是对自身函数的调用。这里我们怎么知道r是对自身的递归调用呢？在λ演算中我们没有对函数定义名字的。这就是给出递归操作Y的原因，例如求和到3</p><script type="math/tex; mode=display">\begin{aligned}YR3= &R(YR)3\\    =& Z30(3S(YR(P3))) \\    =& 3S(YR2)\\    =&3S2S1S0    =6\end{aligned}</script><p>这就是Y组合子(Y combinator)!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://cgnail.github.io/academic/lambda-1/&quot; tar</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ffmpeg常用命令</title>
    <link href="http://yoursite.com/2019/04/27/ffmpeg/ffmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/04/27/ffmpeg/ffmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2019-04-27T10:25:49.000Z</published>
    <updated>2021-12-12T17:27:14.398Z</updated>
    
    <content type="html"><![CDATA[<p>记录下工作中常用的ffmpeg命令，有些网络上不好查找到，需要总结。用md不知道怎么排版比较合适</p><hr><h2 id="1-编码"><a href="#1-编码" class="headerlink" title="1. 编码"></a>1. 编码</h2><p>u_p444_b10的YUV→100M的YUV420的24fps的HDR10码流（单帧，每帧YUV重复2秒）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># u_p444_b10的YUV→100M的YUV420的24fps的HDR10码流（单帧，每帧YUV重复2秒）</span></span><br><span class="line"><span class="comment"># "如果要非单帧的，将前面一个""-r 0.5""去掉即可；重复10s，用""""-r 0.1""""；如果yuv仅有一帧，编码会有错误，所以至少2帧进行repeat"""</span></span><br><span class="line">ffmpeg -threads 16 -r 0.5 -s 3840x2160 -pix_fmt yuv444p10 -i input.yuv -b:v 100M -vf scale=out_h_chr_pos=0:out_v_chr_pos=0,format=yuv420p10 -c:v libx265 -preset ultrafast -x265-params <span class="string">"keyint=24:colorprim=bt2020:transfer=smpte2084:colormatrix=bt2020nc:master-display=G(13250,34500)B(7500,3000)R(34000,16000)WP(15635,16450)L(10000000,50):max-cll=0,0"</span> -an -y -r 24 output.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># u_p444_b10的YUV→100M的YUV420的24fps的SDR码流（单帧，每帧YUV重复2秒）</span></span><br><span class="line">ffmpeg -threads 16 -r 0.5 -s 3840x2160 -pix_fmt yuv444p10 -i input.yuv -b:v 100M -vf scale=out_color_matrix=bt709:out_h_chr_pos=0:out_v_chr_pos=0,format=yuv420p10 -c:v libx265 -preset ultrafast -x265-params <span class="string">"colorprim=bt709:transfer=bt709:colormatrix=bt709"</span> -an -y -r 24 output.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># u_p444_b10的YUV→100M的YUV420的24fps的HLG码流（单帧，每帧YUV重复2秒）</span></span><br><span class="line">ffmpeg -threads 16 -r 0.5 -s 3840x2160 -pix_fmt yuv444p10 -i input.yuv -b:v 100M -vf scale=out_h_chr_pos=0:out_v_chr_pos=0,format=yuv420p10 -c:v libx265 -preset ultrafast -x265-params <span class="string">"keyint=24:colorprim=bt2020:transfer=arib-std-b67:colormatrix=bt2020nc"</span> -an -y -r 24 output.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># u_p420_b8的YUV→100M的YUV420p10的24fps的SDR码流（单帧，每帧YUV重复2秒）</span></span><br><span class="line">ffmpeg -threads 16 -r 0.5 -s 1920x1080 -pix_fmt yuv420p -i input.yuv -b:v 100M -s 3840x2160 -vf scale=out_color_matrix=bt709:out_h_chr_pos=0:out_v_chr_pos=0,format=yuv420p10 -c:v libx265 -preset ultrafast -x265-params <span class="string">"colorprim=bt709:transfer=bt709:colormatrix=bt709"</span> -an -y -r 24 output.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 720x480_p422_b8的YUV→100M的YUV422p8的24fps的SDR码流（单帧，每帧YUV重复2秒）</span></span><br><span class="line"><span class="comment"># 一帧即可完成，但是V811不支持这个格式，需要更换编码库</span></span><br><span class="line">ffmpeg -threads 16 -r 0.2 -s 720x480 -pix_fmt yuv422p -i input.yuv -b:v 100M -c:v libx265 -preset ultrafast -x265-params -an -y -r 24 output.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 720x480_p422_b8的YUV→100M的YUV422p8的24fps的SDR码流（单帧，每帧YUV重复10秒）</span></span><br><span class="line"><span class="comment"># 注意至少需要两帧，但第二帧不会被repeated，总共只有10这里采用MPEG4编码库，不知道为何X265时V811支持不了</span></span><br><span class="line">ffmpeg -r 0.1 -s 720x480 -pix_fmt yuv422p -i input.yuv -b:v 100M -vcodec mpeg4 -an -y -r 24 output.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编码时重新添加旋转的metadata</span></span><br><span class="line">ffmpeg -I input.mp4 -c copy -metadata:s:v:0 rotate=90 output.mp4</span><br></pre></td></tr></table></figure><h2 id="2-解码"><a href="#2-解码" class="headerlink" title="2. 解码"></a>2. 解码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接解码出YUV444的码流</span></span><br><span class="line">ffmpeg -i input.mp4 -pix_fmt yuv444p10 -y output.yuv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码YUV444的码流，并指定30帧和分辨率</span></span><br><span class="line">ffmpeg -i input.mp4 -frames:v 30 -pix_fmt yuv444p10 -s 3840x2160 -y output.yuv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码YUV444的码流，并指定时间段和分辨率</span></span><br><span class="line">ffmpeg -i input.mp4 -ss 00:00:54 -t 00:00:10 -pix_fmt yuv444p10 -s 3840x2160 -y output.yuv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将码流分段解出yuv，每段持续2秒，总共最多解500帧，指定输出分辨率为f_p444_b10</span></span><br><span class="line"><span class="comment"># （ 注意直接使用命令行时用一个""%""，在脚本中要转义用""%%""）"</span></span><br><span class="line">ffmpeg -i input.mp4 -frames:v 500 -pix_fmt yuv444p10 -s 1920x1080 -f segment -segment_time 2 -y output_%%04d.yuv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从制定时间开始截取一帧，并制定分辨率和格式</span></span><br><span class="line">ffmpeg -i input.mp4 -ss 00:00:54 -frames:v 1 -pix_fmt yuv444p10 -s 3840x2160 -y output.yuv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码时进行反交错deinterlace（有两种方法，但是主观效果差异应该不大）</span></span><br><span class="line">ffmpeg -i input.mp4 -deinterlace -pix_fmt yuv444p10 output.yuv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缩放</span></span><br><span class="line">ffmpeg -s 3840x2160 -pix_fmt yuv444p10 -i input.yuv -vf scale=iw*2:ih*2 output.yuvffmpeg -i input.jpg -vf scale=iw*w:ih*2 output.jpg</span><br><span class="line">ffmpeg -i input.avi -vf scale=320:240 output.avi</span><br><span class="line">ffmpeg -i input.avi -vf scale=320:-1 otuput.avi</span><br><span class="line">ffmpeg -i input.avi -vf <span class="string">"scale=iw/2:ih/2"</span> output.avi</span><br><span class="line">ffmpeg -s 1920x1080 -pix_fmt yuv444p10 -i input.yuv -vf scale=iw*2:ih*2 output.yuv</span><br><span class="line">ffmpeg -s 1920x1080 -pix_fmt gray10 -i input.yuv -vf scale=iw*2:ih*2 output.yuv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解YUV4448bit</span></span><br><span class="line">ffmpeg -i input.mp4 -pix_fmt yuv444p -y output.yuv</span><br></pre></td></tr></table></figure><h2 id="3-拼接"><a href="#3-拼接" class="headerlink" title="3. 拼接"></a>3. 拼接</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将多段ts流拼接</span></span><br><span class="line">ffmpeg -i concat:<span class="string">"u_r24_sdr_bt709.ts|u_r24_sdr_bt2020.ts|u_r24_sdr_pq.ts|u_r24_sdr_hdr10.ts|u_r24_sdr_hlg10.ts"</span> -c copy -an -y u_r24_b10_sscimf.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时拼接4路；做8K用</span></span><br><span class="line">ffmpeg -i 1.mp4 -i 2.mp4 -i 3.mp4 -i 4.mp4 -filter_complex <span class="string">"[0:v]pad=iw*2:ih*2[a];[a][1:v]overlay=w[b];[b][2:v]overlay=0:h[c];[c][3:v]overlay=w:h"</span> out.mp4</span><br></pre></td></tr></table></figure><h2 id="4-截取"><a href="#4-截取" class="headerlink" title="4. 截取"></a>4. 截取</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从指定时间开始截取一段码流</span></span><br><span class="line">ffmpeg -i input.mp4 -ss 00:00:05.2 -t 00:00:10 -c copy output.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从指定时间开始截取一帧</span></span><br><span class="line">ffmpeg -i input.mp4 -ss 00:00:05 -frames:v 1 -pix_fmt yuv444p10 -y output.yuv</span><br></pre></td></tr></table></figure><h2 id="5-转码-scaler"><a href="#5-转码-scaler" class="headerlink" title="5. 转码/scaler"></a>5. 转码/scaler</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将码流转码成420p10</span></span><br><span class="line">ffmpeg -i input.mp4 -vf format=yuv420p10 output.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将码流转码成fhd</span></span><br><span class="line">ffmpeg -i input.mp4 -vf scale=1920:1080 output.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将码流转码成uhd</span></span><br><span class="line"><span class="comment"># 但是HDR的metadata会丢失掉</span></span><br><span class="line">ffmpeg -i input.mp4 -vf scale=3840:2160 output.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新拷贝音视频流，可修复视频时间戳不正确等问题</span></span><br><span class="line">ffmpeg -i input.mp4 -c:v copy -c:a copy output.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将UHD YUV转成FHD YUV</span></span><br><span class="line">ffmpeg -s 3840x2160 -pix_fmt yuv444p10 -i input.yuv -vf scale=1920:1080 -pix_fmt yuv444p10 output.yuv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将UHD YUV444转成V210；"跟scalar效果基本一致，UV的值略偏右，目前没有看出来差异"</span></span><br><span class="line">ffmpeg -s 3840x2160 -pix_fmt yuv444p10 -i input.yuv -vcodec v210 output.yuv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将V210转成YUV444 FHD</span></span><br><span class="line"><span class="comment"># 5529600刚好是一帧V210格式的大小，可能与标准的YUV422计算有一定的偏差，因为可能有偏移或者头 https://trac.ffmpeg.org/ticket/1869</span></span><br><span class="line">ffmpeg -f image2pipe -vcodec v210 -s 1920x1080 -frame_size 5529600 -i 1920x1080_ducks_v210.yuv</span><br></pre></td></tr></table></figure><h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># "将u_p444_b10的yuv图像以50M的码率编成420的1fps的SDR码流</span></span><br><span class="line"><span class="comment"># 5秒对应1帧原图，改变了帧率，STB播放异常，但是编码速度较快）</span></span><br><span class="line">ffmpeg -threads 16 -r 0.2 -s 3840x2160 -pix_fmt yuv444p10 -i input.yuv -b:v 50M -vf scale=out_color_matrix=bt709:out_h_chr_pos=0:out_v_chr_pos=0,format=yuv420p10 -c:v libx265 -preset medium -x265-params  <span class="string">"colorprim=bt709:transfer=bt709:colormatrix=bt709"</span> -an -y -r 1 output.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># "将u_p444_b10的yuv图像以近无损方式编成10bit420的24fps的SDR码流（pq=0）</span></span><br><span class="line"><span class="comment"># 不过码流通常会过高，可能达到400M，一般不可行"""</span></span><br><span class="line">ffmpeg -threads 16 -pix_fmt yuv444p10 -s 3840x2160 -r 24 -i input.yuv -vf scale=out_h_chr_pos=0:out_v_chr_pos=0,format=yuv420p10 -c:v libx265 -preset medium -x265-params qp=0:keyint=24:colorprim=bt709:transfer=bt709:colormatrix=bt709 -an -y otuput.mp4</span><br></pre></td></tr></table></figure><h2 id="7-备注"><a href="#7-备注" class="headerlink" title="7. 备注"></a>7. 备注</h2><ol><li>在编码的时候如果指定-preset ultrafast则速度会比-preset medium快不少，大约只要1/3的时间（单帧编码测试结果）。官方文档表示图像质量是一致的，文件大小有差异，但实测文件大小差异不大</li></ol><h2 id="8-ffprobe"><a href="#8-ffprobe" class="headerlink" title="8. ffprobe"></a>8. ffprobe</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取帧数（速度很慢，需要解出来才能获取）</span></span><br><span class="line">ffprobe -v error -count_frames -select_streams v:0 -show_entries stream=nb_read_frames -of default=nokey=1:noprint_wrappers=1 input.mp4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 说是上面一个方法的快速版本，直接查询容器</span></span><br><span class="line">ffprobe -v error -count_frames -select_streams v:0 -show_entries stream=nb_frames -of default=nokey=1:noprint_wrappers=1 input.mp4</span><br></pre></td></tr></table></figure><h2 id="9-mediainfo"><a href="#9-mediainfo" class="headerlink" title="9. mediainfo"></a>9. mediainfo</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取帧数（速度比ffprobbe快很多）</span></span><br><span class="line">mediainfo --Output=<span class="string">"Video;%FrameCount%"</span> input.mp4</span><br></pre></td></tr></table></figure><h2 id="10-ref"><a href="#10-ref" class="headerlink" title="10. ref"></a>10. ref</h2><ul><li><a href="https://www.cnblogs.com/wolf-song/p/7708364.html" target="_blank" rel="noopener">多个视频文件合成画中画效果（Python、ffmpeg）</a></li><li><a href="https://blog.csdn.net/weiwen12138/article/details/70344681" target="_blank" rel="noopener">ffmpeg 命令行实现多路视频拼接播放</a>]</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录下工作中常用的ffmpeg命令，有些网络上不好查找到，需要总结。用md不知道怎么排版比较合适&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1-编码&quot;&gt;&lt;a href=&quot;#1-编码&quot; class=&quot;headerlink&quot; title=&quot;1. 编码&quot;&gt;&lt;/a&gt;1. 编码&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>git使用小记</title>
    <link href="http://yoursite.com/2019/04/27/git%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/04/27/git%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/</id>
    <published>2019-04-27T03:06:09.000Z</published>
    <updated>2021-12-12T17:27:14.398Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://github.com/hongiii/gitNotes_from_Liao" target="_blank" rel="noopener">gitNotes_from_Liao</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的Git教程</a></li></ul><p>记录git使用过程的一些问题和方法。</p><h2 id="集中式VS分布式版本控制系统"><a href="#集中式VS分布式版本控制系统" class="headerlink" title="集中式VS分布式版本控制系统"></a>集中式VS分布式版本控制系统</h2><p>集中式版本管理系统，版本库是集中在中央服务器的，需要先从中央服务器同步下来，然后再推送回去，因此必须联网才能工作。而分布式版本控制系统则没有中央服务器，每个人的电脑上都是一个完整的版本库，因此工作的时候不需要联网，需要协作的时候只需要将相互的修改推动给对方，互相就可以看到修改了。<br>因此两者之间的历史版本维护位置不同，Git本地库包含了代码库还有历史库，在本地就可以记录历史，而SVN的历史库位于中央仓库，每次对比和提交代码都必须链接到中央库。<br>由于每个人的电脑都有完整的版本库，因此其安全性很高，某一个人的电脑坏了无关紧要。当然实际使用的时候，很少是是两个人之间的进行版本库的推送，一般也有一台机器充当中央服务器，该服务器的作用仅仅是用来方便大家之间的交流。</p><h2 id="本地和远程同步"><a href="#本地和远程同步" class="headerlink" title="本地和远程同步"></a>本地和远程同步</h2><p>本地库要推送到远端，但这两个git库不相关，例如已有本地库，然后github上又新建了项目</p><ul><li><a href="https://blog.csdn.net/guotingting923/article/details/80162896" target="_blank" rel="noopener">上传本地项目到github远程仓库</a></li><li><a href="https://www.centos.bz/2018/03/git-%E5%87%BA%E7%8E%B0-fatal-refusing-to-merge-unrelated-histories-%E9%94%99%E8%AF%AF/" target="_blank" rel="noopener">git 出现 fatal: refusing to merge unrelated histories 错误</a></li><li><a href="https://www.jianshu.com/p/71e8dbd14b30" target="_blank" rel="noopener">GitHub使用部分—本地库和远程库之间的同步</a></li></ul><p>方法一<br>可以先将远程库拉下来，然后再将本地的代码拷贝到远端库下载到本地库，然后在提交，这样相当于一次update。不过这样子不能记录原有的git记录</p><p>方法二<br>强制关联推送</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地先正常init、add和commit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关联远程库</span></span><br><span class="line">$ git remote add origin https://github.com/AstrayWu/utils_python.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果远端库已经存在，则进行删除再关联</span></span><br><span class="line">$ git remote rm origin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用--allow-unrelated-hisotries进行强制关联</span></span><br><span class="line">$ git pull origin master --allow-unrelated-hisotries</span><br><span class="line"></span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><ul><li><a href="https://www.yiibai.com/git/git_push.html" target="_blank" rel="noopener">git push命令 - 易百教程</a> </li><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">2.5 Git 基础 - 远程仓库的使用</a></li><li><a href="https://www.cnblogs.com/qianqiannian/p/6008140.html" target="_blank" rel="noopener">Git push 常见用法</a></li></ul><p>用<code>git remote</code>查看配置的远程库名字，一般<code>origin</code>是Git克隆的远程仓库服务器的默认名字。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git remote <span class="comment"># 查看配置的远程库名字</span></span><br><span class="line">$ git remote -v <span class="comment"># 显示对应的URL</span></span><br><span class="line">$ git remote add &lt;shortname&gt; &lt;url&gt; <span class="comment"># 添加远程库并制定简称</span></span><br><span class="line">$ git remote add pb https://github.com/paulboone/ticgit</span><br><span class="line">$ git remote add pb git@github.com:paulboone/ticgit.git</span><br><span class="line">$ git remote -v</span><br><span class="line">$ git fetch [remote-name] <span class="comment"># 有了简写后就可以用简写代替远程库的名字</span></span><br><span class="line">$ git push [remote-name] [branch-name]</span><br><span class="line">$ git push -u origin master 第一次同步时使用该命令</span><br><span class="line">$ git push origin master</span><br><span class="line">origin https://github.com/schacon/ticgit (fetch)</span><br><span class="line">origin https://github.com/schacon/ticgit (push)</span><br><span class="line">pb https://github.com/paulboone/ticgit (fetch)</span><br><span class="line">pb https://github.com/paulboone/ticgit (push)</span><br></pre></td></tr></table></figure><p><code>git push</code>的用法为，冒号后面直接加远程分支名：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。下面命令表示删除origin主机的master分支。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin :master</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">git push origin --delete master</span><br></pre></td></tr></table></figure><p>如果当前分支与多个主机存在追踪关系，则可以使用<code>-u</code>选项指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code>。下面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用<code>git push</code>了。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h2 id="工作区、暂存区和版本库"><a href="#工作区、暂存区和版本库" class="headerlink" title="工作区、暂存区和版本库"></a>工作区、暂存区和版本库</h2><p>工作区：在电脑里能看到的目录； 版本库：在工作区有一个隐藏目录.git，是Git的版本库。 Git的版本库中存了很多东西，其中最重要的就是称为stage（或者称为index）的暂存区，还有Git自动创建的master，以及指向master的指针HEAD。<br><img src="/2019/04/27/git使用小记/2019-04-28-00-01-11.png" alt="工作区、暂存区和版本库"><br>进一步解释一些命令：<br><code>git add</code>实际上是把文件添加到暂存区<br><code>git commit</code>实际上是把暂存区的所有内容提交到当前分支</p><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><p>查看修改内容</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git diff <span class="comment"># 可以查看工作区(work dict)和暂存区(stage)的区别</span></span><br><span class="line">git diff --cached <span class="comment"># 可以查看暂存区(stage)和分支(master)的区别</span></span><br><span class="line">git diff HEAD -- &lt;file&gt; <span class="comment"># 可以查看工作区和版本库里面最新版本的区别</span></span><br></pre></td></tr></table></figure><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p>查看提交日志</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=oneline <span class="comment"># 简化日志输出信息</span></span><br></pre></td></tr></table></figure><h2 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h2><p>查看命令历史</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><ul><li><a href="https://cloud.tencent.com/developer/article/1358036" target="_blank" rel="noopener">Git Reset命令- 腾讯云</a></li></ul><p>版本回退<br>返回上一个版本，在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本是HEAD^^，往上100个版本写成<code>HEAD~100</code>。commit_id是版本号，是一个用SHA1计算出的序列</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><ul><li><code>git reset --soft HEAD^</code>：将最近一次提交节点的提交记录回退到暂存区</li><li><code>git reset --mixed HEAD^</code>：将最近一次提交节点的提交记录回退到工作区</li><li><code>git reset --hard HEAD^</code>：将最近一次提交节点的提交记录全部清除</li></ul><p>eg：<br>在Master分支中，首先通过<code>git add test.txt</code>将test.txt文件添加到暂存区，再通过<code>git commit -m &quot;add file test.txt &quot;</code>将暂存区的内容作为一次提交记录添加到提交区，最后如果没问题的话就可以通过<code>git push origin master</code>将这次提交push到远端仓库。</p><p>使用</p><ol><li><p>修改commit的message，有点类似<code>amend</code>操作<br> 如果此时发现提交记录的comment写错了，如将<code>git commit -m &quot;add file test.txt&quot;</code>写成了<code>git commit -m &quot;ad file test.txt&quot;</code>，那么就可以使用    <code>git reset --soft HEAD^</code>将本次提交回退到暂存区，再重新把comment补全，进行一次提交。</p></li><li><p>修改commit的文件<br>如果此时发现提交记录里有一个文件多提交了，或者有一个文件漏添加到暂存区而没有在此次提交内，则可以通过<code>git reset --mixed HEAD^</code>将本次提交都回退到没有添加到暂存区之前，然后再重新add需要提交的文件后，再重新add</p></li><li><p>完全撤销此次commit<br>如果此时发现修复一个BUG完全错了，希望取消这次提交，并且把代码回退到没有改动的话，则需要使用<code>git reset --hard HEAD^</code>，来将这次提交全部回退。</p></li></ol><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><h3 id="丢弃工作区的修改"><a href="#丢弃工作区的修改" class="headerlink" title="丢弃工作区的修改"></a>丢弃工作区的修改</h3><p>该命令是指将文件在工作区的修改全部撤销，这里有两种情况：</p><ol><li>file自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>file已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>总之，就是让这个文件回到最近一次git commit或git add时的状态。也就是将工作区的状态回退到暂存区或者版本库。</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure><h3 id="丢弃暂存区的修改"><a href="#丢弃暂存区的修改" class="headerlink" title="丢弃暂存区的修改"></a>丢弃暂存区的修改</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt; <span class="comment"># 第一步，把暂存区的修改撤销掉(unstage)，重新放回工作区：</span></span><br><span class="line">git checkout -- &lt;file&gt; <span class="comment"># 第二步，撤销工作区的修改</span></span><br></pre></td></tr></table></figure><p>小结：</p><ol><li>当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- &lt;file&gt;</code>。</li><li>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了第一步，第二步按第一步操作。</li><li>已经提交了不合适的修改到版本库时，想要撤销本次提交，进行版本回退，前提是没有推送到远程库。</li></ol><h2 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h2><p>删除文件</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git rm &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上等价于，注意是提交到暂存区</span></span><br><span class="line">rm &lt;file&gt;</span><br><span class="line">git add &lt;file&gt;</span><br></pre></td></tr></table></figure><p>进一步的解释<br>Q: 比如执行了rm text.txt 误删了怎么恢复？<br>A: 执行<code>git checkout -- text.txt</code> 把版本库的东西重新写回工作区就行了</p><p>Q: 如果执行了<code>git rm text.txt</code>我们会发现工作区的text.txt也删除了，怎么恢复？<br>A: 先撤销暂存区修改，重新放回工作区，然后再从版本库写回到工作区</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset head text.txt</span><br><span class="line">git checkout -- text.txt</span><br></pre></td></tr></table></figure><h2 id="远程库"><a href="#远程库" class="headerlink" title="远程库"></a>远程库</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"youremail@example.com"</span> <span class="comment"># 创建SSH Key</span></span><br><span class="line">git remote add origin https://github.com/username/repositoryname.git <span class="comment"># 关联远程仓库</span></span><br><span class="line">git push -u origin master <span class="comment"># 第一次推送到远程仓库，后续可以省略-u</span></span><br><span class="line"></span><br><span class="line">git remote -v <span class="comment"># 查看远程库信息</span></span><br></pre></td></tr></table></figure><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><ul><li><a href="https://www.yiibai.com/git/git_pull.html" target="_blank" rel="noopener">git pull命令</a></li></ul><p>git pull命令用于从另一个存储库或本地分支获取并集成(整合)。git pull命令的作用是：取回远程主机某个分支的更新，再与本地的指定分支合并，它的完整格式稍稍有点复杂。</p><p>语法的位置和push有点不同，远程主机名在最前，然后push是本地→到远端，pull是远端→本地。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><p>如要要取回origin主机的next分支，与本地的master分支合并，需要写成下面这样：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git pull origin next:master</span><br></pre></td></tr></table></figure><p>如果远程分支(next)要与当前分支合并，则冒号后面的部分可以省略。上面命令可以简写为：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git pull origin next</span><br></pre></td></tr></table></figure><p>上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再执行git merge。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git merge origin/next</span><br></pre></td></tr></table></figure><h3 id="fetch和-pull的区别"><a href="#fetch和-pull的区别" class="headerlink" title="fetch和 pull的区别"></a>fetch和 pull的区别</h3><ul><li><a href="https://www.yiibai.com/git/git_pull.html" target="_blank" rel="noopener">git pull命令</a></li></ul><p>一般使用pull会简单些，不过可能要解决冲突</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git pull <span class="comment"># 相当于是从远程获取最新版本并merge到本地</span></span><br><span class="line">git fetch <span class="comment"># 相当于是从远程获取最新版本到本地，不会自动merge</span></span><br></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch &lt;branchname&gt; <span class="comment"># 创建分支</span></span><br><span class="line">git branch <span class="comment"># 列出所有分支，当前分支前面会标一个*号。</span></span><br><span class="line">git checkout &lt;branchname&gt; <span class="comment"># 切换分支</span></span><br><span class="line">git checkout -b &lt;branchname&gt; <span class="comment"># 创建+切换分支</span></span><br><span class="line">git merge &lt;branchname&gt; <span class="comment"># 合并某分支到当前分支</span></span><br><span class="line">git branch -d &lt;branchname&gt; <span class="comment"># 删除分支</span></span><br><span class="line">git <span class="built_in">log</span> --graph <span class="comment"># 查看分支合并图</span></span><br><span class="line">git merge --no-ff -m <span class="string">"description"</span> &lt;branchname&gt; <span class="comment"># 普通模式合并分支</span></span><br><span class="line"><span class="comment"># 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。合并分支时，加上--no-ff参数就可以用普通模式合并，能看出来曾经做过合并，包含作者和时间戳等信息，而fast forward合并就看不出来曾经做过合并。</span></span><br><span class="line"></span><br><span class="line">git branch -D &lt;branchname&gt; <span class="comment"># 丢弃一个没有合并过的分支</span></span><br></pre></td></tr></table></figure><h2 id="reflog"><a href="#reflog" class="headerlink" title="reflog"></a>reflog</h2><ul><li><a href="https://blog.csdn.net/u013252047/article/details/80230781" target="_blank" rel="noopener">git命令log与reflog的比较</a></li></ul><p>git log 命令可以显示所有提交过的版本信息；git log 命令可以显示所有提交过的版本信息</p><h2 id="现场"><a href="#现场" class="headerlink" title="现场"></a>现场</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git stash <span class="comment"># 保存工作现场</span></span><br><span class="line">git stash list <span class="comment"># 查看工作现场</span></span><br><span class="line">git stash pop <span class="comment"># 恢复工作现场</span></span><br></pre></td></tr></table></figure><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag &lt;tagname&gt; <span class="comment"># 用于新建一个标签，默认为HEAD，也可以指定一个commit id。</span></span><br><span class="line">git tag -a &lt;tagname&gt; -m &lt;description&gt; &lt;branchname&gt; or commit_id <span class="comment"># 指定标签信息</span></span><br><span class="line">git tag <span class="comment"># 查看所有标签</span></span><br><span class="line">git push origin &lt;tagname&gt; <span class="comment"># 推送一个本地标签</span></span><br><span class="line">git tag -d &lt;tagname&gt; <span class="comment"># 删除一个本地标签</span></span><br><span class="line">git push origin :refs/tags/&lt;tagname&gt; <span class="comment"># 删除一个远程标签；也就是推送一个空的tag到远程库</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hongiii/gitNotes_from_Liao&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gitNotes_from_Liao&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>常用插件和小工具</title>
    <link href="http://yoursite.com/2019/04/19/%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%92%8C%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2019/04/19/%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%92%8C%E5%B0%8F%E5%B7%A5%E5%85%B7/</id>
    <published>2019-04-18T17:23:42.000Z</published>
    <updated>2021-12-12T17:27:14.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-常用的chrome插件"><a href="#1-常用的chrome插件" class="headerlink" title="1. 常用的chrome插件"></a>1. 常用的chrome插件</h2><ul><li><a href="https://chrome.google.com/webstore/detail/context-menus/phlfmkfpmphogkomddckmggcfpmfchpn" target="_blank" rel="noopener">Context Menus/右键搜索</a></li><li><a href="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">One Tab</a> 基本必备的插件</li><li><a href="https://chrome.google.com/webstore/detail/ie-tab/hehijbfgiekmjfkfjpbkbammjbdenadd?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">IE tab</a> 还没有试验过，不过有些网站确实只支持IE</li><li><a href="https://chrome.google.com/webstore/detail/google-scholar-button/ldipcbpaocekfooobnbcddclnhejkcpn" target="_blank" rel="noopener">Google Scholar Button</a></li><li><a href="https://chrome.google.com/webstore/detail/lastpass-free-password-ma/hdokiejnpimakedhajhdlcegeplioahd" target="_blank" rel="noopener">LastPass: Free Password Manager</a> 以前还挺经常用的，不过现在直接用google账号就可以存好多密码了</li><li><a href="https://chrome.google.com/webstore/detail/wizclipper/jfanfpmalehkemdiiebjljddhgojhfab" target="_blank" rel="noopener">WizClipper/为知笔记</a></li><li><a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc" target="_blank" rel="noopener">Octotree</a> 用于github阅读</li><li><a href="http://www.internetdownloadmanager.com/" target="_blank" rel="noopener">IDM</a> IDM配合chrome使用</li><li><a href="https://chrome.google.com/webstore/detail/ticktick-todo-task-list/diankknpkndanachmlckaikddgcehkod" target="_blank" rel="noopener">TickTick - Todo &amp; Task List</a> 有时候需要同步手机上的清单</li><li><a href="https://chrome.google.com/webstore/detail/%E8%B0%B7%E6%AD%8C%E8%AE%BF%E9%97%AE%E5%8A%A9%E6%89%8B/gocklaboggjfkolaknpbhddbaopcepfp" target="_blank" rel="noopener">谷歌访问助手</a> 没有VPN时候就靠这个活着了</li><li><a href="https://chrome.google.com/webstore/detail/im-feeling-lucky/cnlabakikmdekpfaflaihcepfkjopgll" target="_blank" rel="noopener">I’m Feeling Lucky</a> <a href="https://www.techjunkie.com/im-feeling-lucky/" target="_blank" rel="noopener">How to add Google’s I’m Feeling Lucky Option to Your Chrome Search Engines</a></li></ul><h2 id="2-vscode常用插件及相关配置"><a href="#2-vscode常用插件及相关配置" class="headerlink" title="2. vscode常用插件及相关配置"></a>2. vscode常用插件及相关配置</h2><h3 id="2-1-插件"><a href="#2-1-插件" class="headerlink" title="2.1. 插件"></a>2.1. 插件</h3><ol><li>vscode-icons<br> 文件格式一目了然，左侧文件目录的文件夹和文件都会显示相应的图标</li><li>Bracket Pair Colorizer<br> 括号用不同颜色标识</li><li>Git History<br>在vscode中添加git log</li><li>LaTex language support</li><li>LeetCode</li><li><p>Markdown All in One<br>可以使用github flavored markdown渲染标准</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"markdown.styles": ["D:\\Documents\\01.Github\\01.markdown-css\\github-markdown.css"],</span><br></pre></td></tr></table></figure></li><li><p>Markdown Math<br>在markdown中支持数学公式</p></li><li>Markdown Preview Enhance<br>用于预览markdown</li><li>Markdown Shortcuts<br>添加一些快捷键，写作时比较方便</li><li><p>Markdown TOC<br>添加目录功能注意，并且可以在header中添加序号。<br>根据markdownlint的语法要求，一级标题应该仅有一个座位文章的标题，所以需要在二级标题中启动编号。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"markdown-toc.depthFrom": 2,</span><br></pre></td></tr></table></figure></li><li><p>markdownlint<br>对md文件做语法检查</p></li><li><p>Paste Image<br>方便在.md文件中复制图片，可以配置在当前同文件名的文件夹下，便于分类</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"pasteImage.path": "$&#123;currentFileDir&#125;/$&#123;currentFileNameWithoutExt&#125;/",</span><br></pre></td></tr></table></figure></li><li><p>Setting Sync</p></li><li><p>TODO Highlight<br>高亮TODO并扩展</p></li><li><p>OneDark-Pro<br>Atom’s ionic主题（首选项-颜色主题修改主题    </p></li><li>T</li></ol><h3 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2. 配置"></a>2.2. 配置</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"editor.mouseWheelZoom": true,</span><br><span class="line">"editor.fontFamily": "Consolas, 'Courier New', monospace",</span><br><span class="line">"workbench.colorTheme": "One Dark Pro",</span><br></pre></td></tr></table></figure><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><ul><li><a href="https://aoenian.github.io/2018/12/24/vscode-markdown-to-pdf/" target="_blank" rel="noopener">vscode编辑markdown文件并导出为PDF格式</a></li></ul><h2 id="3-实用的软件"><a href="#3-实用的软件" class="headerlink" title="3. 实用的软件"></a>3. 实用的软件</h2><h3 id="3-1-实际使用"><a href="#3-1-实际使用" class="headerlink" title="3.1. 实际使用"></a>3.1. 实际使用</h3><ul><li>SumatraPDF/福昕阅读器 小巧的PDF阅读器，不过不能编辑</li><li>Total Commander/Q-Dir/Clover 多窗口多标签的资源管理器，文件整理工具</li><li><strong>Launchy</strong>/Wox 快速启动</li><li><strong>Eeverthing</strong> 快速搜索</li><li>MediaInfo 强大的视频参数检测工具</li><li>MathType Word中插入公式</li><li>calibre 电子书管理器</li><li>KMSpico 用于注册Microsoft Office</li><li>Potplayer 好用的视频播放器</li><li><strong>Ditto</strong> 剪切板管理工具，可以记录多个剪切板，写代码很实用</li><li>火绒安全软件</li><li>Internet Download Manager 下载工具</li><li>Listary Pro 还没用起来，文件浏览工具，TODO</li><li><strong>MobaXterm</strong>/cmder XShell的替代品，全能终端神器</li><li>ShadowsocksR-dotnet4.0 VPN工具</li><li>搜狗壁纸 桌面管理工具</li><li>欧路词典 可以自由搭配词典，自由性比较高</li><li>Thunder5 使用专门版本的迅雷，不会被限速，简单速度高</li><li><strong>Beyond Compare</strong> 比对工具</li><li><strong>Quicker</strong> 效率神器，启动、复制、查找等重复性工作的自动化工具</li><li>TeamViewer 功能强大的远程控制软件</li><li>WinSCP SCP文件传输软件，有点类似Total Commander的界面，同步很方便</li><li>每日英语听力 练习英语</li><li>软媒魔方 系统优化工具</li><li><strong>Snipaste</strong> 简单强大的截图工具，很实用</li><li>Mathpix Snip 数学公式的OCR工具，用于Latex等</li><li>Xmind/幕布 思维导图工具，TODO</li><li>为知笔记 笔记工具</li><li><strong>unlocker</strong> 强力解除工具，用于解决文件占用问题</li><li>Geek Uninstaller 还未使用，TODO</li><li><strong>DesktopCal</strong> 桌面日历</li><li>Seer、QuickLook windows查看工具，TODO</li><li>Screen to GIF/Ocam fit录制/剪辑工具</li><li>冰点下载 百度文库的免费下载器</li><li>Collagelt 拼图，TODO</li><li>7-Zip</li><li>SpaceSniffer</li><li>Duplicate Cleaner TODD</li><li>SyncToy 文件夾同步工具 TODO</li><li>Icaros 让资源管理器能够显示所有视频格式缩略图，缩略图拓展增强插件 Icaros TODO</li><li>Smallpdf</li><li><a href="https://github.com/soimort/you-get" target="_blank" rel="noopener">you-get</a> 下载视频神器</li></ul><h3 id="3-2-ref"><a href="#3-2-ref" class="headerlink" title="3.2. ref"></a>3.2. ref</h3><ul><li><a href="https://www.zhihu.com/question/300735799/answer/604585413" target="_blank" rel="noopener">有哪些软件堪称神器，却不为大众所知？</a></li></ul><h2 id="4-实用的网站"><a href="#4-实用的网站" class="headerlink" title="4. 实用的网站"></a>4. 实用的网站</h2><ul><li><a href="https://mubu.com/" target="_blank" rel="noopener">极简大纲笔记 | 一键生成思维导图</a></li><li><a href="https://uzer.me/" target="_blank" rel="noopener">UZER.ME云端超级应用空间</a></li><li><a href="http://bigjpg.com/" target="_blank" rel="noopener">AI人工智能图片放大</a></li><li><a href="https://burner.bonanza.com/" target="_blank" rel="noopener">Background Burner: Remove Image Backgrounds Free &amp; Fast</a> 抠图</li><li><a href="https://www.wolframalpha.com/" target="_blank" rel="noopener">wolframalpha</a></li><li><a href="http://tools.jb51.net/" target="_blank" rel="noopener">脚本之家</a></li></ul><h2 id="5-Office"><a href="#5-Office" class="headerlink" title="5. Office"></a>5. Office</h2><ul><li><a href="https://www.jiandaoyun.com/f/5b4fe560ba4f62256657ec95" target="_blank" rel="noopener">Office插件</a></li><li><a href="http://www.hippter.com/" target="_blank" rel="noopener">HiPPTer</a></li><li><a href="http://www.ffcell.com/" target="_blank" rel="noopener">方方格子</a></li></ul><h2 id="6-IOS"><a href="#6-IOS" class="headerlink" title="6. IOS"></a>6. IOS</h2><ul><li><a href="https://www.zhihu.com/question/271740133" target="_blank" rel="noopener">在当下使用 iPad 有哪些值得推荐的应用？</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-常用的chrome插件&quot;&gt;&lt;a href=&quot;#1-常用的chrome插件&quot; class=&quot;headerlink&quot; title=&quot;1. 常用的chrome插件&quot;&gt;&lt;/a&gt;1. 常用的chrome插件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://c</summary>
      
    
    
    
    
  </entry>
  
</feed>
